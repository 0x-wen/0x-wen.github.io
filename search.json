[{"title":"OrbitDB-初体验","url":"/blog/2024/05/15/note/open-source/OrbitDB-%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"1.项目分析1.1 项目分析为去中心化网络设计的点对点（P2P）数据库，下面是关于 OrbitDB 的一些关键点和如何部署及与之交互的概述：\n1.2 主要功能\n无服务器（Serverless）：不需要中心化的服务器来运行。\n分布式（Distributed）：数据分布在网络中的各个节点上。\n点对点（Peer-to-Peer）：直接在用户之间同步数据，不需要通过中介。\n使用 IPFS 作为数据存储：IPFS（InterPlanetary File System）是一个分布式文件系统，用于存储和访问文件、网站、应用程序等。\n使用 Libp2p Pubsub 进行数据库同步：Libp2p 是一个模块化的网络栈，Pubsub 是它的一个模块，用于发布和订阅消息，以实现数据库的自动同步。\n最终一致性（Eventually Consistent）：数据库保证了在没有冲突的情况下，最终所有副本都将达到一致的状态。\n使用 Merkle-CRDTs 进行冲突自由的数据库写入和合并：CRDTs（Conflict-free Replicated Data Types）是一种特殊类型的数据结构，允许在没有中心协调者的情况下进行数据的并发更新。\n\n1.3 数据库类型OrbitDB 提供了不同类型的数据库以适应不同的数据模型和用例：\n\nevents：不可变的（仅追加）日志，具有可遍历的历史记录。\ndocuments：可以存储和按指定键索引 JSON 文档的文档数据库。\nkeyvalue：类似于传统的键值数据库。\nkeyvalue-indexed：在 LevelDB 中索引的键值数据。\n\n1.4 部署和交互\n安装：可以通过 npm 安装 OrbitDB 及其依赖：\nnpm install @orbitdb/core helia\n\n浏览器中使用：OrbitDB 可以通过在 HTML 文件中使用 &lt;script&gt; 标签来加载：\n&lt;script src=&quot;/path/to/orbitdb.min.js&quot;&gt;&lt;/script&gt;\n\n快速开始：可以使用 @orbitdb/quickstart 模块快速开始使用 OrbitDB。\n\n使用：在浏览器或 Node.js 应用中，可以将 @orbitdb/core 作为一个模块与 IPFS 的 JavaScript 实例一起使用。以下是创建和使用数据库的示例代码：\nimport &#123; createHelia &#125; from &#x27;helia&#x27;;import &#123; createOrbitDB &#125; from &#x27;@orbitdb/core&#x27;;import &#123; gossipsub &#125; from &quot;@chainsafe/libp2p-gossipsub&quot;;import &#123; identify &#125; from &quot;@libp2p/identify&quot;;import &#123; createLibp2p &#125; from &#x27;libp2p&#x27;;// 创建 Libp2p 实例和 IPFS 实例const libp2p = await createLibp2p(&#123; /* options */ &#125;);const ipfs = await createHelia(&#123; libp2p &#125;);const orbitdb = await createOrbitDB(&#123; ipfs &#125;);// 创建/打开数据库const db = await orbitdb.open(&quot;my-database-name&quot;);// 监听来自其他节点的更新db.events.on(&quot;update&quot;, async (entry) =&gt; &#123;  // 处理更新&#125;);// 添加条目到数据库const hash = await db.add(&#123; content: &quot;Hello, OrbitDB!&quot; &#125;);// 查询数据库for await (const record of db.iterator()) &#123;  // 处理记录&#125;// 关闭数据库和 IPFS 实例await db.close();await orbitdb.stop();await ipfs.stop();\n\n持久化和连接：为了配置 IPFS 实例的持久化和 Libp2p 连接到其他节点，可以参考 @orbitdb/quickstart 中的 Helia 实例创建和默认的 Libp2p 配置。\n\n文档和开发：项目的 README 中提供了更多关于如何运行测试、构建项目、基准测试和构建 API 文档的指导。\n\n\n","tags":["open-source"]},{"title":"02-探讨事务一致性","url":"/blog/2024/05/16/blockchain/0-base/02-%E6%8E%A2%E8%AE%A8%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7/","content":"1.事务的ACID特性在数据库中，“事务”是由多个操作构成的序列。广义上的事务一致性具化到了原子性、一致性、隔离性和持久性这4个方面。\n\n原子性（Atomicity）：指事务是一个不可分割的操作单元，要么全部执行成功，要么全部失败回滚。如果事务中的任何一个操作失败，整个事务将回滚到最初的状态。\n一致性（Consistency）：指事务将数据库从一个一致状态转变为另一个一致状态。在事务开始和结束时，数据库必须满足预定义的一致性规则，以保持数据的有效性和完整性。\n隔离性（Isolation）：指每个事务的执行应该与其他事务的执行相互隔离，以防止彼此干扰。隔离级别定义了事务之间的隔离程度，包括已提交读、可重复读、快照隔离和可串行化。\n持久性（Durability）：指一旦事务提交，其结果就应该永久保存在数据库中，即使系统发生故障也不会丢失。数据库通过将事务日志持久化到磁盘来实现持久性。\n\n\n1.1 原子性和一致性的差异原子性关注事务内部状态，要不全部成功，要不全部失败\n一致性关注数据可见性，中间状态的数据对外不可见，只有最初状态和最终状态的数据对外可见\n1.2 持久性核心思想即应对系统故障\n目的都是保证在本地节点之外，至少有一份完整的日志可用于数据恢复。\n\n存储硬件无损、可恢复故障： 主要依托于预写日志（Write Ahead Log, WAL）保证第一时间存储数据。WAL采用顺序写入的方式，可以保证数据库的低延时响应。\n存储硬件损坏、不可恢复的故障： 需要用到日志复制技术，将本地日志及时同步到其他节点。\n\n单体数据库自带的同步或半同步的方式，其中半同步方式具有一定的容错能力\n日志存储到共享存储系统上，后者会通过冗余存储保证日志的安全性\n基于Paxos&#x2F;Raft的共识算法同步日志数据，在分布式数据库中被广泛使用\n\n1.3 隔离性分为多个隔离级别\n较低的隔离级别就是在正确性上做妥协，将一些异常现象交给应用系统的开发人员去解决，从而获得更好的性能。\n\n最早、最正式的对隔离级别的定义，是ANSI SQL-92（简称SQL-92），它定义的隔离级别和异常现象如下所示：\n\n1.4 更严谨的隔离级别参考论文“A Critique of ANSI SQL Isolation Levels”（简称Critique）\n定义了六种隔离级别和八种异常现象\n\n\nSQL-92中可重复读与可串行化两个隔离级别的主要差别是对幻读的处理，是不是解决了幻读就是可串行化\nCritique的发表，快照隔离能解决幻读的问题，但却无法处理写倾斜（Write Skew）问题，也不符合可串行化要求\n\n对比总结到今天，使用最广泛的隔离级别为四种：已提交读、可重复读、快照隔离、可串行化\n1.5 异常现象不可重复读和幻读的差异在语义上接近：都是在一个事务内用相同的条件查询两次，但两次的结果不一样\n不可重复读：第二次的结果集相对第一次，有些记录被修改（Update）或删除（Delete）了\n幻读： 第二次结果集里出现了第一次结果集没有的记录(Insert)，幻读是在第一次结果集的记录“间隙”中增加了新的记录\n1.6 快照隔离 &amp;&amp; 可重复读\n两者在强度上并列，已提交读弱于这两者，大多数数据库支持的隔离级别就在这三者之中\n\n快照隔离的实现基础则是多版本并发控制（MVCC），用于更高效地实现乐观或悲观并发控制。\n快照隔离存在写倾斜的问题：\n\n两个事务T1、T2同时针对10个变量赋值\nT1将10个变量赋值A，T2将10个变量赋值B，在多事务并行下得到结果将是5个A和B\n\n根据可串行化的定义，“多事务并行执行所得到的结果，与串行执行（一个接一个）完全相同”。\n实现可串行化：先执行T1再执行T2，10个变量都会变成A；调换T1与T2的顺序，则10个变量都是B。\n1.7 数据一致性和事务一致性\n数据一致性关注的是单对象、单操作在多副本上的一致性\n事务一致性则是关注多对象、多操作在单副本上的一致性\n\n分布式数据库的一致性是数据一致性与事务一致性的融合。\n分布式数据“强一致性”的含义，意味着要实现严格串行化，同时也带来性能上的损失。\n降低隔离级别则是在正确性上做妥协，将异常给应用开发处理，从而获得更好的性能。\n","categories":["blockchain-collection"],"tags":["blockchain"]},{"title":"00-开篇","url":"/blog/2023/03/03/software-test-collection/00-%E5%BC%80%E7%AF%87/","content":"1.初衷在职场中迷茫是常见的经历，为了激励自己继续前行，总结过往经历并进行优化是一个不错的做法。\n关于软件测试的经历，带着问题去实践寻找答案：\n1.1 目标与动机：最初选择这个行业的动机是什么？目标是什么？有两句话一直警示着我，在此分享给大家\n\n如果建筑工人盖房子的方式跟程序员写程序一样，那第一只飞来的啄木鸟就将毁掉人类文明\n软件测试的价值在于将原本暴露在用户面前的缺陷，提前在内部发现并解决\n\n然后基于很多项目或公司实际情况，不能说测试无用但收益甚微【小公司尤其明显】，存在的问题可能是多种多样的，一方面是企业对质量的重视程度，一方面是测试人员本身技能不足都有关系。\n1.2 技能与知识：掌握技能主要是为了解决实际问题\n比如常见的接口测试，需要掌握一些接口调试工具：postman、curl等\n手工测试进度很慢就需要引入自动化，比如掌握一门编程语言和发请求的库，针对业务场景结合完成测试\n对于性能测试则需要掌握压测工具，特定场景下工具无法解决问题，就多掌握一门高性能编程语言，本质还是在处理发起请求的问题\n在分布式系统中重点关注数据一致性的解决方案，从理解共识算法开始更容易发现应用层的错误，以及发现错误后如何推理并找出问题所在\n\n技能终究是工具，掌握多样化的工具是为了在解决问题时提供解决方案，去做别人不可替代的事才有价值。\n2.软测基本三阶段2.1 入门、初级\n入门不难，周期短，一般计算机专业的学生对于软件开发有一定经验，通过三个月的自学也能达到岗位需求\n技术栈比较浅，特别是在当前市场环境下，不推荐入坑\n\n2.2 中、高级\n目前市场上需求，至少需要熟悉自动化测试、性能测试，掌握一门编程语言，有测试平台的开发经验更佳\n\n普遍岗位也没有太深入，大部分还是api调用工程师，不过能有专职的自动化岗位还是不错的，主要有时间能沉下心去学习，在持续的学习中接触到更多的知识才会发现自己掌握的只是冰山一角\n\n很多高级测试也只是编写维护自动化而已，自动化能解决一些问题，也会带来问题\n\n什么时候要自动化？如何自动化？自动化程度如何，全部还是部分\n维护成本也不能忽视，为了测试程序招了比开发还水的团队维护着大量的测试代码，这本就是一个伪命题\n\n\n测试开发岗、对于大厂而言还有精力和能力去打磨高效的测试平台，其要求的能力并不低普遍对标开发水平。除大厂内部自研的系统外，目前并没有明星产品的推出能一统天下，各系统不同关注点都需要编码去实现。\n推荐两个平台关注下：\n\nRunnerGo go 微服务开发技术栈，一款全栈式测试平台\nMeterSphere java 技术栈，一站式开源持续测试平台\n\n\n\n2.3 资深、专家、测试管理\n某特定场景下能提供完整解决方案，拿人钱财替人消灾\n代码审计，软件架构，优化方案，解决核心问题的能力提高了自然会成为所谓的专家\n有了架构师，所谓测试架构师存在的意义又是什么呢？\n\n3.改变在步入web3行业后，工作中发现在此领域中大家对于软件的质量尤其关注，特别是智能合约\n测试经验在智能合约开发中是尤为重要的一部分，web3领域对于安全的缺口也很大\n4.总结4.1 要做软测知识汇总，以实际工作为主，做实践项目输出主要帮助的人群是长期功能测试&#x2F;自动化无法落地的同学提升竞争力\n4.2 要学习web3并形成个人的知识体系，并培养自己在web3行业的竞争力除了个人需要较强的自制力外，还需要有良好的团队组队，以交流促进学习并相互监督\n4.3 选对路比盲目努力重要首先要相信选择的路是有希望的，才能坚持学下去，目标先掌握rust，上山的路其实并不拥挤\n\n共勉。\n","categories":["software-test-collection"],"tags":["software-test"]},{"title":"100-钱包类别","url":"/blog/2024/05/17/blockchain/100-wallet/100-%E9%92%B1%E5%8C%85%E7%B1%BB%E5%88%AB/","content":"1.钱包类别\nWeb3钱包的核心差异在于私钥的管理方式。私钥是用户访问和控制其加密货币资产的关键。\n\n\n中心化钱包：私钥由中心服务器管理，如交易所钱包（Binance、okx）。\n\n去中心化钱包：私钥存储在用户设备上，如TP、ImToken、MetaMask。采用确定性分层钱包结构，提供更高的个人控制权。\n\n硬件钱包：私钥存储在离线硬件设备中，代表产品如Ledger、OneKey，通过蓝牙、NFC或串口与用户设备通信，实现安全签名。\n\n交易所Web3钱包：集成了中心化、去中心化和硬件钱包的功能。\n\n托管钱包：托管钱包通常指的是由第三方服务提供商管理私钥的钱包。\n\n多签钱包：基于M-of-N的签名机制，要求一定数量的签名才能授权交易，如Gnosis Safe。\n\nMPC钱包：采用秘密共享技术来管理和生成加密货币私钥的钱包。\n\n社交恢复钱包：两种主要的恢复机制：守护者恢复和私钥分片恢复。\n\nEVM链AA钱包：遵循ERC4337协议，提供账户抽象功能，实现智能合约级别的钱包服务。\n\n\n2.中心化钱包2.1 架构和工作原理\n私钥存储：中心化钱包的私钥通常存储在中心服务器上，由服务提供者管理。用户不直接控制私钥，而是通过账户和密码来访问自己的资产。\n加密技术：为了保护私钥，中心化钱包服务提供者会采用各种加密技术，如DES加密、AES加密等，将私钥加密后存储。\n签名机制：当用户发起交易时，钱包服务会解密私钥，使用私钥对交易进行签名，然后将签名后的交易发送到区块链网络。\n\n2.2 业务流程\n批量地址生成：为了提高性能和响应速度，中心化钱包会预先生成大量的地址，存放在地址池中，用户注册时直接分配地址。\n充值：用户向钱包地址发送加密货币，钱包服务通过扫描区块链来确认交易，并更新用户的账户余额。\n提现：用户提交提现请求，钱包服务验证请求后，使用私钥签名交易，并将加密货币发送到用户指定的地址。\n归集：将分散在多个地址中的资金归集到一个或几个地址中，以便于管理和使用。\n热转冷：将热钱包中的资金转移到冷钱包中，以提高安全性。\n冷转热：从冷钱包中转移资金到热钱包，以便用户进行交易。\n链路风控：实施风险控制措施，确保交易的安全性，防止欺诈和非法活动。\n\n2.3 安全性\n内部风险：由于私钥由中心化服务管理，存在内部人员滥用权限的风险。\n外部攻击：中心化钱包可能成为黑客攻击的目标，一旦被攻破，用户资产将面临巨大风险。\n合规性：中心化钱包通常需要遵守严格的监管要求，包括KYC（了解你的客户）和AML（反洗钱）政策。\n\n2.4 用户体验\n便捷性：用户不需要管理私钥，只需记住账户和密码，使用起来相对简单。\n服务依赖：用户的资产安全和服务可用性高度依赖于中心化钱包的运营状况。\n\n2.5 优势与劣势\n优势：操作简便，适合新手用户；交易速度快，服务响应及时。\n劣势：用户对资产的控制权较低；存在中心化服务的风险，如内部欺诈、黑客攻击等。\n\n3.去中心化钱包\n也称为非托管钱包，它允许用户完全控制自己的私钥和资金，而不需要依赖于第三方服务\n\n3.1 核心特点\n私钥控制：用户完全控制自己的私钥，这是访问和转移加密货币的关键。\n非托管：没有中心化的实体持有用户的资产或私钥，用户对自己的资产有完全的控制权。\n确定性分层钱包（HD Wallet）：支持分层确定性钱包结构，可以从一个主种子（通常是助记词）生成多个地址。\n\n3.2 架构和工作原理\n本地存储：私钥通常存储在用户的设备上，如电脑、手机或专用硬件设备。\n加密保护：私钥在本地以加密形式存储，需要用户设置的密码或PIN码来解锁。\n签名交易：用户发起交易时，交易会在本地设备上使用私钥签名，然后广播到区块链网络。\n\n3.3 类型\n软件钱包：安装在用户设备上的应用程序，如MetaMask、Keplr等。\n硬件钱包：专门的硬件设备，如Ledger和Trezor，它们在设备内部安全地存储私钥。\n纸钱包：将私钥和地址打印在纸上，是一种冷存储方式，但易受物理损害。\n\n3.4 业务流程\n生成钱包：用户创建新钱包时，系统会生成一个私钥和相应的公钥和地址。\n备份助记词：生成一组助记词（通常为12或24个单词），用于恢复钱包。\n接收资金：用户可以将加密货币发送到钱包的公钥地址。\n发送交易：用户发起交易时，需要输入密码或PIN码来解锁钱包并签名交易。\n查看余额和交易：用户可以查看钱包的余额和交易历史。\n\n3.5 安全性\n私钥安全：私钥的安全性完全取决于用户，需要妥善保管。\n加密保护：私钥在本地加密存储，增加了安全性。\n多签名：支持多签名钱包，需要多个私钥共同签名才能进行交易，提高了安全性。\n\n3.6 用户体验\n控制权：用户对自己的资产有完全的控制权。\n隐私性：交易和余额信息不需要与任何中心化实体共享。\n技术门槛：相对于中心化钱包，去中心化钱包可能需要用户具备一定的技术知识。\n\n3.7 优势与劣势\n优势：用户完全控制自己的资产；提高了安全性和隐私性；支持多种区块链资产。\n劣势：用户需要自己管理私钥，增加了责任；可能需要更高的技术知识；交易速度可能较慢。\n\n4.硬件钱包\n提供高安全性的加密货币存储解决方案，专门设计的物理设备，用于生成、存储和管理私钥，以确保用户资产的安全。\n\n核心特点\n离线存储：硬件钱包将私钥存储在设备内部，与互联网隔离，减少了在线黑客攻击的风险。\n冷存储：作为一种冷存储解决方案，硬件钱包不常连接到网络，只在需要时与设备交互。\n私钥生成：私钥在设备内部生成，确保了私钥的随机性和安全性。\n用户控制：用户完全控制硬件钱包中的私钥，没有第三方介入。\n\n架构和工作原理\n嵌入式系统：硬件钱包通常基于嵌入式系统，具有有限的硬件资源，专注于安全功能。\n安全元件：使用专门的安全元件（如安全处理器或加密协处理器）来保护私钥。\n用户界面：配备有小屏幕和按钮，用于显示交易信息和用户操作确认。\n通信接口：通过USB、蓝牙、NFC等接口与用户设备通信。\n\n主要功能\n地址生成：硬件钱包可以生成多个地址，通常遵循BIP32、BIP39等标准。\n交易签名：硬件钱包在设备内部对交易进行签名，确保私钥不会暴露给用户设备。\n备份与恢复：支持助记词或种子短语备份，允许用户恢复钱包。\n多签名支持：一些硬件钱包支持多签名交易，增加交易的安全性。\n\n操作流程\n初始化：用户设置硬件钱包，生成新的种子短语，并妥善保存。\n接收资金：用户通过硬件钱包提供的公钥地址接收资金。\n发送交易：\n用户在计算机或手机上创建交易请求。\n将交易详情传输到硬件钱包。\n硬件钱包显示交易信息，用户确认无误后，通过按钮确认签名。\n硬件钱包对交易进行签名，并将签名后的交易返回给用户设备。\n用户将签名后的交易广播到区块链网络。\n\n\n备份与恢复：在需要时，用户可以使用种子短语恢复钱包。\n\n安全性\n抵御网络攻击：由于私钥不接触网络，硬件钱包能有效抵御网络攻击。\n物理安全：硬件钱包的物理安全性取决于其构建质量和用户如何保管设备。\n抗胁迫功能：一些硬件钱包提供虚假的PIN码或助记词，以防止在胁迫情况下泄露真实信息。\n\n用户体验\n高安全性：为用户提供银行级别的资产保护。\n易用性：尽管设置了安全措施，但大多数硬件钱包仍设计为用户友好。\n成本：硬件钱包需要购买，存在一定的成本。\n\n优势与劣势\n优势：极高的安全性；私钥不触网；支持多种加密货币；易于使用。\n劣势：需要购买硬件设备；交易时需要物理设备；可能存在设备损坏或丢失的风险。\n\n5.交易所Web3钱包核心特点\n集成性：作为交易所平台的一部分，用户可以直接在交易所内进行资产的存储、转账和交易。\n多功能：除了基本的钱包功能，还可能提供去中心化应用（DApp）的交互、代币交换、借贷等高级功能。\n用户界面：提供用户友好的界面，便于用户管理和使用其加密资产。\n\n架构和工作原理\n中心化管理：用户的私钥由交易所管理，这与中心化钱包相似，便于交易所进行快速的交易处理。\n去中心化交互：支持与区块链上的智能合约和DApp的交互，允许用户进行去中心化的交易和操作。\n热钱包与冷钱包：结合热钱包（在线钱包）和冷钱包（离线钱包）的使用，以提供安全性和便捷性的平衡。\n\n主要功能\n资产管理：用户可以在钱包中查看和管理自己的加密货币资产。\n交易执行：用户可以直接在钱包界面上执行买卖订单。\n智能合约交互：支持与智能合约的交互，使用户能够参与到去中心化金融（DeFi）项目中。\n代币收发：用户可以发送和接收各种加密货币代币。\n多签支持：可能支持多签名钱包功能，增加交易的安全性。\n\n操作流程\n账户创建：用户在交易所注册账户，并创建Web3钱包。\n私钥管理：私钥由交易所安全地管理，用户通过账户验证来访问钱包功能。\n资金存入：用户可以通过转账将加密货币存入交易所钱包。\n交易和投资：用户利用钱包内的资金进行市场交易或参与DeFi项目。\n资金提取：用户可以将资金从钱包提取到个人地址或其他钱包。\n\n安全性\n中心化风险：由于私钥由交易所管理，用户需要信任交易所的安全性和信誉。\n多重签名：一些交易所可能提供多重签名保护，增加交易的安全性。\n冷存储：交易所通常会将大部分资产存储在冷钱包中，以抵御网络攻击。\n\n用户体验\n便捷性：用户可以在一个平台上完成交易和资产管理，无需在多个钱包间转移资金。\n功能丰富：提供多种金融功能，满足用户的不同需求。\n安全性：虽然不如硬件钱包安全，但通过多重签名和冷存储等措施提高了安全性。\n\n优势与劣势\n优势：操作便捷，功能集成；用户界面友好；快速交易执行。\n劣势：中心化管理可能带来安全风险；用户对资产的控制权较低。\n\n6.托管钱包\n提供一种高度安全的方式来存储和管理私钥。通常由一个可信的第三方机构管理，如专业的托管服务提供商或金融机构。\n\n核心特点\n第三方管理：私钥由第三方机构管理，而不是由用户直接控制。\n安全性高：通过专业的安全措施和协议来保护私钥，适用于存储大量资产。\n合规性：托管钱包服务提供商通常需要遵守严格的监管要求，包括KYC和AML政策。\n\n架构和工作原理\n多签名技术：托管钱包通常采用多签名技术，即需要多个签名者中的一定数量同意才能授权交易。\n分层确定性钱包结构：支持分层确定性钱包（HD Wallet），可以从一个种子短语生成多个地址。\n冷存储：私钥存储在离线环境中，如硬件安全模块（HSM）或冷库，以提高安全性。\n\n主要功能\n资产保管：为用户提供加密货币资产的保管服务。\n交易执行：用户可以发起交易请求，由托管服务执行实际的交易。\n审计和报告：提供资产审计和交易报告服务，有助于合规性和透明度。\n风险管理：通过专业的风控措施，帮助用户管理资产风险。\n\n操作流程\n注册和验证：用户在托管服务提供商处注册账户，并完成必要的身份验证。\n资产存入：用户将加密货币发送到托管钱包提供的地址。\n交易请求：用户通过托管服务的用户界面或API发起交易请求。\n交易执行：托管服务在验证用户请求后，执行交易并将结果通知用户。\n资产提取：用户可以请求将资产从托管钱包提取到指定地址。\n\n安全性\n专业安全措施：托管服务提供商采用高级的安全技术和协议，如SSL加密、多因素认证等。\n保险：一些托管服务为存储的资产提供保险，以覆盖潜在的安全事件造成的损失。\n合规性：遵循监管要求，定期进行安全审计和合规检查。\n\n用户体验\n高安全性：为用户提供银行级别的资产保护。\n专业服务：提供专业的资产管理和交易执行服务。\n监管合规：帮助用户满足监管要求，降低合规风险。\n\n优势与劣势\n优势：提供高安全性的资产保管；专业的管理和服务；帮助用户满足监管要求。\n劣势：用户需要支付服务费用；对资产的控制权较低；需要信任第三方机构的信誉和安全性。\n\n7.多签钱包\n多签钱包（Multi-signature Wallets），是一种需要多个私钥中的一定数量（M个中的N个，即M-of-N）共同签署才能授权交易的加密货币钱包\n\n核心特点\n多重签名：交易需要多个私钥中的至少M个签名才能被授权。\n提高安全性：减少了单点故障的风险，即使部分私钥泄露，资产仍然安全。\n灵活性：用户可以根据需要设置M和N的值，以及哪些私钥参与签名。\n\n架构和工作原理\n私钥生成：每个参与方生成自己的私钥，并保留好。\n公钥组合：所有参与方的公钥被组合在一起，用于生成钱包地址。\n交易签署：当需要发起交易时，必须收集到足够的签名（至少M个）才能进行。\n智能合约支持：多签钱包通常基于智能合约实现，特别是在以太坊等支持智能合约的区块链上。\n\n主要功能\n资产共享管理：多个用户可以共同管理钱包中的资产。\n交易授权：交易需要多个签名，增加了交易的安全性。\n权限分配：可以根据需要分配不同的权限给不同的私钥持有者。\n审计和追踪：所有交易都需要多个签名，易于审计和追踪。\n\n操作流程\n创建钱包：创建多签钱包时，需要确定M和N的值，以及参与方的公钥。\n生成私钥：每个参与方生成自己的私钥，并妥善保管。\n发起交易：一个参与方发起交易请求，但交易尚未最终授权。\n收集签名：交易请求被发送给其他参与方，他们用自己的私钥签署交易。\n交易执行：收集到足够的签名后，交易被广播到区块链网络并执行。\n\n安全性\n抗胁迫：即使一个私钥持有者受到胁迫，也无法单独授权交易。\n抗攻击：需要多个签名才能交易，增加了攻击者盗取资产的难度。\n私钥分散：私钥分散在多个参与方手中，减少了私钥集中泄露的风险。\n\n用户体验\n安全性高：适合需要高安全级别的用户和组织。\n操作复杂性：相比于单签名钱包，多签钱包的操作更为复杂。\n协作需求：需要参与方之间的协作来签署和执行交易。\n\n优势与劣势\n优势：提高了安全性和抗风险能力；适合共同管理资产；易于审计和追踪。\n劣势：操作过程可能较为繁琐；需要多个参与方的协作；可能存在协调困难。\n\n8.MPC钱包\n（MPC，Multi-Party Computation），一个完整的私钥被分割多个部分，每个部分由不同的参与方持有。\n\n核心特点\n去中心化控制：私钥以分割的形式存在，没有单一实体能够单独控制私钥。\n增强安全性：私钥的每个部分单独不具有价值，只有组合一定数量的部分才能恢复私钥。\n多方授权：需要多个参与者的份额共同协作才能授权和签署交易。\n\n架构和工作原理\n秘密分割：私钥通过秘密共享算法被分割成多个份额，每个份额包含私钥的一部分信息。\n份额分布：这些份额被分发给不同的参与者，可以是不同的个人、服务器或地理位置。\n阈值设置：设置一个阈值（通常是N个中的M个），只有收集到M个份额时才能恢复私钥。\n交易签署：当需要签署交易时，所有参与者必须协作，提供他们的份额以生成签名。\n\n主要功能\n资产保护：即使部分份额丢失或被盗，只要没有达到阈值，资产仍然安全。\n抗胁迫：单个参与者无法被胁迫透露私钥信息，因为他们不拥有完整的私钥。\n容错性：即使一些份额丢失或损坏，只要有足够的份额，私钥仍然可以被恢复。\n审计和合规：所有交易都需要多个签名，便于审计和满足合规要求。\n\n操作流程\n初始化钱包：创建MPC钱包时，私钥被分割成多个份额，并分配给不同的参与者。\n份额存储：每个参与者安全地存储他们的份额，可能使用硬件安全模块(HSM)或其他安全措施。\n交易请求：用户发起交易请求，需要多个份额来授权。\n份额收集：协调者或智能合约收集足够的份额以重构私钥。\n签名交易：使用重构的私钥对交易进行签名。\n执行交易：将签名后的交易广播到区块链网络。\n\n安全性\n抗盗取：没有单一实体拥有完整的私钥，增加了盗取资产的难度。\n抗内部欺诈：需要多个参与者的协作才能进行交易，减少了内部欺诈的风险。\n抗胁迫：单个参与者即使在胁迫下也无法泄露完整私钥。\n\n用户体验\n高安全性：用户可以放心地保管资产，因为私钥的安全性得到了显著提升。\n操作复杂性：相比于传统钱包，MPC钱包的操作可能更加复杂，需要协调多个参与者。\n信任和协作：需要在参与者之间建立信任和协作机制。\n\n优势与劣势\n优势：提供了极高的安全性；适合需要严格合规的场合；增强了对资产的保护。\n劣势：操作过程可能较为复杂；需要多个参与者的协作；可能涉及较高的协调成本。\n\n9.社交恢复钱包守护者恢复机制在守护者恢复机制中，用户可以指定一组信任的联系人（守护者），他们可以在用户丢失私钥时帮助恢复钱包。这个过程通常涉及以下步骤：\n\n设置守护者：用户在钱包中设置一组信任的联系人（守护者），通常需要他们的公钥或钱包地址。\n私钥丢失：当用户丢失了对钱包的访问权限，例如忘记了密码或丢失了硬件钱包。\n请求恢复：用户向守护者发出帮助恢复的请求。\n多签名交易：守护者们需要按照预设的规则（例如，需要一定数量的守护者同意）签署一个特殊的多签名交易，以证明他们的身份和同意恢复操作。\n恢复钱包：一旦收集到足够数量的签名，就可以通过智能合约或其他机制来恢复钱包的访问权限。\n\n私钥分片恢复机制私钥分片恢复机制则是一种基于秘密共享算法的方法，它将私钥分割成多个部分（分片），并将这些分片分散存储在不同的地点或人那里。以下是私钥分片恢复的一般步骤：\n\n私钥分片：用户的私钥被分割成多个分片，每个分片都通过某种加密方法进行保护。\n分片存储：这些分片可以存储在用户的多个设备上、云端服务、或者交给信任的朋友保管。\n分片恢复：当用户需要恢复私钥时，他们需要收集一定数量的分片（根据设定的阈值，例如5个分片中的3个）。\n重组私钥：收集到足够的分片后，用户可以通过一个解密过程重组原始的私钥。\n访问钱包：一旦私钥被重组，用户就可以重新访问他们的钱包。\n\n社交恢复钱包的优势和挑战\n优势：提供了一种不依赖于单一备份的私钥恢复方式，增加了私钥管理的灵活性和安全性。\n挑战：需要用户信任守护者不会滥用他们的私钥信息，同时也要求用户在社交网络中有一定的信任基础。\n\n10.EVM链AA钱包核心特点\n智能合约钱包：AA钱包本身就是部署在区块链上的智能合约。\n内置安全性：通过智能合约的代码可以实施复杂的安全策略。\nGas代付：允许用户在执行交易时由第三方代付Gas费用。\n\n架构和工作原理\n账户抽象：与传统钱包不同，AA钱包将账户和交易的发送者抽象化，允许更灵活的交易发起和签名方式。\n交易构造：交易的构造可以在链上完成，用户或第三方可以代表AA钱包构造交易。\n签名机制：AA钱包可以使用多种签名机制，包括但不限于传统的ECDSA签名。\n\n主要功能\n代付交易：支持Gas代付功能，允许第三方支付交易费用。\n自定义交易：用户可以自定义交易属性，如nonce、gas限制等。\n多签交易：可以集成多签名机制，提高交易的安全性。\n智能合约交互：作为智能合约，AA钱包可以与其他智能合约进行交互。\n\n操作流程\n部署钱包：在以太坊链上部署AA钱包智能合约。\n资金存入：用户将资金存入AA钱包合约地址。\n交易构造：用户或第三方构造交易，包括确定接收者、金额和数据。\n交易签名：根据AA钱包的配置，可能需要用户或其他参与方的签名。\n交易执行：将构造好的交易发送到区块链网络，由网络中的节点验证和执行。\n\n安全性\n智能合约安全：安全性依赖于智能合约代码的健壮性，需要经过严格的安全审计。\n多签支持：如果集成多签名机制，可以增加交易的安全性。\n自定义安全策略：可以通过智能合约实现自定义的安全策略和检查。\n\n用户体验\n灵活性：提供了高度灵活的交易构造和签名方式。\n降低成本：通过Gas代付功能，可以降低用户的交易成本。\n复杂性：相比于传统钱包，AA钱包的设置和使用可能更复杂。\n\n优势与劣势\n优势：提供更高的安全性；支持Gas代付；允许灵活的交易构造和签名方式。\n劣势：需要用户理解智能合约的概念；可能存在智能合约安全风险。\n\n","categories":["blockchain-collection"],"tags":["blockchain","wallet"]},{"title":"01-分布式基础理论","url":"/blog/2024/05/13/blockchain/0-base/01-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/","content":"1.分布式基础理论1.1 CAP理论是分布式系统的基石Consistency (一致性)：\n“all nodes see the same data at the same time”，即更新操作成功并返回客户端，所有节点在同一时间的数据完全一致，一致性的问题在并发系统中不可避免。\n对于客户端，一致性指的是并发访问时更新过的数据如何获取。\n对于服务端，则是更新如何复制分布到整个系统，以保证数据一致。\nAvailability (可用性):\n“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。良好的可用性是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。\nPartition Tolerance (分区容错性):\n即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。\n比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。\n1.2 三者只能取其二\nCA without P： 如果不要求P（不允许分区），则保留C（强一致性）和A（可用性），但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，这是有违背分布式系统的设计初衷。\nCP without A： 如果不要求A（可用），强调各服务之间数据强一致性，而P（分区）会导致同步时间无限延长(等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验。\nAP wihtout C： 要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，这样会导致全局数据的不一致性。\n\n1.3 Base理论BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写\nBASE是对CAP中一致性和可用性权衡的结果，核心思想是：即使无法做到强一致性，采用适当的方式使系统达到最终一致性。\nBasically Available: 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性，但不等价于系统不可用。\n\n秒杀的场景下用户数量暴增，为保护系统稳定性，有部分用户可能被引导至一个降级页面\n\nSoft state: 允许系统中的数据存在中间状态，并认为中间状态不会影响系统整体可用性，即允许系统在不用节点之间数据同步存在延时\nEventually consistent: 强调所有的数据副本在经过一段时间同步后，最终能够达成一致的状态。最终保证一致，而不是实时保证系统一致性。\nBASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。\n2.区块链不可能三角区块链通常在安全性、去中心化和可扩展性之间进行权衡：\n\n比特币：重点放在安全性和去中心化上，因此导致比特币的可扩展性受限，因为比特币的区块大小和区块时间设定限制了它的交易处理能力。在需求高的时候就会导致交易延迟和手续费上涨。\n以太坊：重点也放在安全性和去中心化上，并作为智能合约平台，它需要确保用户的资产和协议是安全的。因此以太坊的可扩展性较差，尤其当DeFi和NFT的应用量增大时，交易延迟与费用上涨的问题尤其突出。\nSolana：主要关注可扩展性因此在处理速度和吞吐量上都非常高效，为了达到这样的性能，在网络的中心化程度作出了一些妥协，例如限制验证者的数量。\n\n3.概率最终性和逐块最终性概率最终性：在比特币网络中，由于采用了Proof-of-Work的共识算法。尽管一个区块被添加到区块链上，但仍然存在一定的概率（尽管很小），在后续的区块中被另一个竞争者的区块所取代。因此，对于比特币网络来说，一个最新的区块在一段时间后可以被认为具有概率最终性，即随着更多的区块被添加到区块链上，该区块被替代的概率会逐渐减小。\n逐块最终性：对于Cosmos网络，它采用了Tendermint共识算法，该算法通过验证人的投票来确定下一个区块的生成者。一旦在Cosmos网络中的一个区块被验证人成功生成并广播出去，它被认为是最终的结果，不会被后续的区块替代。因此，可以说Cosmos网络具有逐块最终性，即一旦一个区块在网络中被验证人确认，它就成为最终的结果。\n","categories":["blockchain-collection"],"tags":["blockchain"]},{"title":"python-路径导入问题","url":"/blog/2023/01/10/note/python/py-%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/","content":"python文件运行时路径导入的问题\n 错误提示：ModuleNotFoundError: No module named ‘xxxx’\n\n解决这个问题首先要明白Python运行时，Python解释器会按照一定的搜索路径来查找模块和包。\n可以通过sys.path查看具体信息\nimport sysprint(sys.path)\n\n[&#x27;/Users/jw/Documents/github/abcd/b&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python312.zip&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/lib-dynload&#x27;, &#x27;/opt/homebrew/lib/python3.12/site-packages&#x27;, &#x27;/Users/jw/Documents/github/abcd&#x27;]\n\n\n当前工作目录：即列表下标为0的元素，解释器会首先在当前目录中搜索模块，当前工作目录是指在运行Python脚本时所在的目录\nPYTHONPATH环境变量：PYTHONPATH环境变量可以用来指定额外的模块搜索路径。它是一个包含多个目录路径的列表，Python解释器会按照列表中的顺序进行搜索。\n\n# 可以通过以下命令在终端查看echo $PYTHONPATH \n\n这种方式比较隐蔽，不常用，需要操作者知情才会去查看此环境变量\n\n系统默认路径：Python解释器会在一组默认的系统路径中搜索模块。这些路径包括Python标准库的位置以及安装的第三方库的位置。【参考上述path路径中展示，除最后一个元素和第一个元素外】\n\n解决方案abcd/├── a/│ ├── init.py│ └── m.py           # m.py中有一个变量 aa = 11└── b/├── init.py└── mb.py          #  在此路径下运行 mb.py 文件 并打印出变量 aa\n\n# mb.pyfrom a.m import aaprint(aa)File &quot;/Users/jw/Documents/github/abcd/b/mb.py&quot;, line 29, in &lt;module&gt;    from a.m import aaModuleNotFoundError: No module named &#x27;a&#x27;\n\n将模块a添加至path路径中\nimport sysfrom pathlib import Pathroot_path = Path(__file__).resolve().parent.parentsys.path.append(str(root_path))  # 将root_path添加到PATH，并会在此模块下搜索print(sys.path)  # 此处会输出path的所有内容from a.m import aaprint(aa)   # 成功输出变量信息\n\n\n\n类似场景abcd/├── a/│ ├── init.py│ └── m.py           # m.py中有一个变量 aa = 11└── b/├── init.py└── mb.py            #  在此路径下运行 mb.py 文件 并打印出变量 aa└ main.py             # 程序主入口\n\n# mian.pyfrom a.m import aaprint(aa)\n\nmain.py 无需添加至PATH即可成功输出aa变量的原因现在知道了吗？\n根据上述结论推导：\nmain.py文件在运行时，会在当前工作目录下搜索包，即能找到a模块也可以找到b模块，无需添加\n\n","tags":["python"]},{"title":"03-UTXO和Account模型对比","url":"/blog/2024/05/21/blockchain/0-base/03-UTXO%E5%92%8CAccount%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94/","content":"在区块链中常见的两种记录模式：UTXO（Unspent Transaction Output，未花费的交易输出）模型和Account（账户）模型\n1.UTXO模型：区块链中的现金类比在基于 UTXO 的区块链中，加密货币账户余额只是拥有的 UTXO 的总和，如实体钱包中拥有不同面额的钞票一样。\n没有身份的概念，只有关联到不同钱包地址的 UTXO 或者说 “未花费的代币”。\n比特币协议不追踪用户的余额，而是追踪 UTXO 以及这些 UTXO 分别属于哪些地址。\n2.采用UTXO模型的交易步骤\n确定交易金额：发送方确定要发送的加密货币金额。\n\n选择UTXO：发送方的钱包查找足够覆盖交易金额的UTXO。这些UTXO是之前收到但尚未花费的交易输出。\n\n创建交易：钱包创建一笔新的交易，这笔交易包含以下部分：\n\n输入（Inputs）：选择的UTXO列表，这些将被用于支付交易金额。\n输出（Outputs）：至少包含两个输出，一个是支付给接收方的金额，另一个是找零（如果原始UTXO的总和大于所需支付的金额）。\n交易费（Transaction Fee）：为了激励矿工将交易纳入区块链，发送方需要支付一定的交易费。\n\n\n签署交易：发送方使用与其钱包地址相关联的私钥对交易进行数字签名。这个签名证明了交易是由拥有私钥的用户发起的。\n\n广播交易：签署后的交易被广播到区块链网络中，网络中的节点会接收这笔交易。\n\n节点验证：网络中的节点接收到交易后，会进行验证，确保：\n\n交易格式正确。\n输入的UTXO是有效的，且未被花费过。\n签名与UTXO的公钥匹配。\n交易费用合理。\n\n\n交易池（Mempool）：验证通过的交易会被放入节点的交易池（mempool）中，等待被矿工打包进区块。\n\n矿工打包交易：矿工从交易池中选择交易进行打包，创建一个新的区块。\n\n区块链更新：当新区块被成功挖出并添加到区块链上时，交易被认为是确认的。此时，UTXO集会更新：\n\n交易中使用的输入UTXO从UTXO集中移除。\n新创建的输出成为新的UTXO，添加到UTXO集中。\n\n\n交易确认：随着区块被添加到区块链上，交易得到网络的确认。\n通常需要多个后续区块（即几个确认）来增加交易的安全性。\n\n1个确认：交易已经被打包进最新的区块，但仍然存在被回滚（reorg）的风险，尤其是当矿工算力非常集中时。\n3个确认：交易被认为相对安全，因为它需要重新计算3个区块的工作量证明才能被更改。\n6个确认：这通常被认为是一个较高的安全标准，需要更多的时间和资源来回滚交易。\n\n在一些高价值交易或对安全性有更高要求的场景中，可能会等待更多的确认来确保交易不可逆。\n\n接收方确认：\n\n接收方或其钱包会检查区块链，确认交易已经被纳入区块并且有足够的确认。\n\n\n\n3.UTXO模型优缺点优点：\n提高隐私性：由于每次交易都可以使用新的地址，UTXO模型提供了较高的隐私保护，使得追踪用户的资金流向更加困难。\n支持并行处理：UTXO模型允许区块链网络并行处理交易，因为每个交易的验证不依赖于其他交易，这有助于提高交易吞吐量。\n无状态性：UTXO模型是无状态的，意味着节点不需要维护一个全局的状态表，这使得系统更加简洁和易于维护。\n\n缺点：\n缺乏可编程性：UTXO模型本身不支持复杂的脚本和智能合约功能，限制了区块链的可编程性和灵活性。\n交易灵活性降低：在UTXO模型中，每笔交易都需要精确地花费一个或多个UTXO，并产生找零，这增加了交易的复杂性。\n\n4.Account模型：区块链中的银行账户类比最初由以太坊采用，类似于传统银行账户的处理方式。在这种模型中，交易直接反映在用户账户的余额变化上。\n在账户余额上做加减操作，由网络节点来维护用户余额的分布式账本，存在身份的概念通常于与账户或者地址关联\n5.采用Account模型的交易步骤\n创建交易：发送方决定交易的接收方地址和要发送的金额。\n交易签名：发送方使用他们的私钥对交易进行签名，以证明身份并授权这笔交易。\n交易广播：签名后的交易被发送到区块链网络中的节点。\n交易验证：网络中的节点接收到交易后，会进行一系列验证，包括检查签名的有效性、确保发送方账户有足够的余额以及交易是否符合其他网络规则。\n交易费用计算：根据交易的复杂性和大小，计算所需的交易费用。\n交易池存储：验证通过的交易被存储在节点的交易池（mempool）中，等待被打包进区块。\n区块打包：矿工或验证者从交易池中选择交易，并将其打包进新的区块。\n共识机制：通过工作量证明（Proof of Work）或权益证明（Proof of Stake）等共识机制，新区块被添加到区块链中。\n状态更新：当新区块被确认后，账户的状态（余额和非货币属性）会根据交易内容进行更新。\n交易确认：交易被网络中的其他节点确认，并且随着区块的增加，交易的确认深度也会增加，从而提高交易的安全性。\n交易完成：一旦交易被确认并且相应的状态变更被记录在区块链上，交易就被认为是完成的。\n\n6.Account模型优缺点优点：\n易于理解：Account模型类似于传统的银行账户系统，用户容易理解账户余额和交易的概念。\n\n可编程性：Account模型通常支持图灵完备的智能合约，允许开发者编写复杂的逻辑和去中心化应用。\n\n简化的交易结构：交易通常只需要包含发送者、接收者、金额和数据，结构相对简单。\n\n\n缺点：\n状态存储需求：Account模型需要存储每个账户的状态，随着用户数量的增加，状态数据可能会迅速增长。\n隐私性：由于账户地址与所有交易直接关联，可能更容易分析和追踪用户的行为模式。\n网络拥堵：Account模型通常需要按顺序处理交易，这在高需求时可能导致网络拥堵。\n\n","categories":["blockchain-collection"],"tags":["blockchain"]},{"title":"python-重复逻辑优化篇","url":"/blog/2023/08/21/note/python/py-%E9%87%8D%E5%A4%8D%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96%E7%AF%87/","content":"1.解决api请求变更,URL和参数更新维护等问题？引入客户端代码生成工具,根据接口文档自动生成代码,从而减少由于接口变更的维护成本\n官网地址: https://swagger.io/tools/swagger-codegen/\n\n下载swagger codegen \n生成对应语言客户端代码  [-i 指定api接口路径,-lang 指定语言,-o 指定生成代码文件路径]\n\n阅读生成项目的readme,提供了使用教程​\t\t\nswagger-codegen generate -i http://ip:port/static/openapi.yml --lang python -o ./me_api_clientswagger-codegen generate -i http://ip:port/static/openapi.yml --lang go -o ./me_api_client\n\n\n\n\n2. 项目结构分析\n客户端需要连接到指定节点，能提供多节点测试\n客户端需要提供命令生成器 和 执行器\n操作每个模块都需要自定义其模块方法，成本较高，并且大致逻辑一致\n\nNode模块：\n\n初始化node实例提供连接节点功能\nnode实例默认提供对应 交易的一些常用命令设置\nnode都绑定有执行器(executor) 和 命令生成器（generate_xxx）\n\nimport inspectfrom typing import Callablefrom loguru import loggerfrom config.config import app_chainfrom ssh import Client, Resultclass Node:    ssh_client = Client(ip=app_chain.Host.ip, port=app_chain.Host.port,                        username=app_chain.Host.username, password=app_chain.Host.password)    config = app_chain    def __init__(self, node: str):        super().__init__()        if &quot;--node&quot; not in node:            node = f&quot;--node=&#123;node&#125;&quot;        self.config.Flags.node = node        self.superadmin = self.__get_superadmin_addr()        self.__init_instance_config()    def update_config(self, attr: str, key: str, value: str):        &quot;&quot;&quot;        If key exists in the attr object, replace the value. If no, add the value        :param attr: &#x27;ApplicationChain&#x27; object must have attr        :param key:        :param value:        :return:        &quot;&quot;&quot;        sub_cfg_gen = getattr(self.config, attr)        found_key = False        for i in sub_cfg_gen:            if i[0] == key:                setattr(sub_cfg_gen, key, value)                found_key = True                break        if not found_key:            setattr(sub_cfg_gen, key, value)    def __init_instance_config(self):        self.update_config(&quot;Flags&quot;, &quot;fees&quot;, &quot;--fees=100umec&quot;)        self.update_config(&quot;Flags&quot;, &quot;gas&quot;, &quot;--gas=200000&quot;)    @property    def base_cmd(self):        return f&quot;&#123;self.config.Host.chain_work_path&#125; &quot;    def __get_superadmin_addr(self):        get_superadmin_cmd = f&quot;&#123;self.base_cmd&#125; keys show superadmin -a &#123;self.config.Flags.keyring_backend&#125;&quot;        return self.ssh_client.exec_cmd(get_superadmin_cmd)    def generate_query_cmd(self, cmd: str):        query_cmd = self.base_cmd + f&quot;&#123;self.config.Flags.node&#125; &#123;self.config.GlobalFlags.chain_id&#125; &quot;        return query_cmd + cmd    def generate_tx_cmd(self, cmd: str):        tx_cmd = self.base_cmd + (f&quot;&#123;self.config.Flags.fees&#125; &#123;self.config.Flags.gas&#125; &quot;                                  f&quot;&#123;self.config.Flags.yes&#125; &#123;self.config.Flags.keyring_backend&#125; &quot;                                  f&quot;&#123;self.config.Flags.node&#125; &#123;self.config.GlobalFlags.chain_id&#125; &quot;)        return tx_cmd + cmd    def generate_keys_cmd(self, cmd: str):        keys_cmd = self.base_cmd + f&quot;&#123;self.config.Flags.keyring_backend&#125; &quot;        return keys_cmd + cmd    def executor(self, cmd):        logger.info(f&quot;&#123;inspect.stack()[0][3]&#125;: &#123;cmd&#125;&quot;)        if &quot;keys add&quot; in cmd:            _ = self.ssh_client.channel.send(cmd + &quot;\\n&quot;)            resp_info = self.ssh_client.Interactive.read_channel_data(self.ssh_client.channel)            if &quot;existing&quot; in resp_info:                resp_info = self.ssh_client.Interactive.input_yes_or_no(self.ssh_client.channel)            assert &quot;**Important**&quot; in resp_info            return resp_info        resp_info = self.ssh_client.exec_cmd(cmd, strip=False)        if resp_info.failed:            logger.info(f&quot;resp_info.stderr: &#123;resp_info.stderr&#125;&quot;)            return resp_info.stderr        return Result.yaml_to_dict(resp_info.stdout)\n\n\n\nMeta元类:\n为每个类动态生成方法,解决其定义冗余\nclass Meta(type):    def __init__(cls, name, bases, attrs):        cls.module = name.lower()  # 创建类module = 其类名称小写        super().__init__(name, bases, attrs)        sub_module = attrs.get(&#x27;sub_module&#x27;, [])        parent_module = attrs.get(&#x27;parent_module&#x27;, &#x27;&#x27;)        if isinstance(sub_module, list):            for module in sub_module:              \t# 添加类方法，名称为其子模块                method = cls.generate_method(parent_module, module)                setattr(cls, module, classmethod(method))        elif isinstance(sub_module, dict):            for k, module in sub_module.items():                method = cls.generate_method(parent_module, module)                setattr(cls, k, classmethod(method))        else:            raise f&quot;sub_module type error: &#123;type(sub_module)&#125;, expect list or dict&quot;    @staticmethod    def generate_method(parent_module, sub_module) -&gt; Callable[..., str]:       # 利用闭包特性，生成的类方法只接受 *args,**kwargs 参数        def method(cls, *args, **kwargs):            return cls.build_command(parent_module, sub_module, *args, **kwargs)        return method    def build_command(cls, parent_module, sub_module, *args, **kwargs):        args_str = &quot; &quot;.join(map(str, args))        kwargs_str = &quot; &quot;.join([f&quot;--&#123;key&#125;=&#123;value&#125;&quot; for key, value in kwargs.items() if value != &quot;&quot;])        return f&quot;&#123;parent_module&#125; &#123;cls.module&#125; &#123;sub_module&#125; &#123;args_str&#125; &#123;kwargs_str&#125; &quot;    def __getattr__(cls, attr):        raise AttributeError(f&quot;&#x27;&#123;cls.__name__&#125;&#x27; class has no attribute &#x27;&#123;attr&#125;&#x27;&quot;)    def help(cls):        for attr_name in cls.sub_module:            attr = getattr(cls, attr_name)            if not callable(attr):                raise TypeError(f&quot;attribute &#x27;&#123;attr_name&#125;&#x27; is not callable&quot;)        print(f&quot;Available methods: &#123;list(cls.sub_module)&#125;&quot;)        print(f&quot;Example usage: &#123;cls.__name__&#125;.&#123;list(cls.sub_module)[0]&#125;(&#x27;argument&#x27;)&quot;)\n\n\n\n","tags":["python","tools"]},{"title":"100-cosmpy实践","url":"/blog/2024/05/19/software-test-collection/100-%E5%AE%9E%E8%B7%B5/100-cosmpy%E5%AE%9E%E8%B7%B5/","content":"1.cosmpy源码解读1.1 项目简介基于 Cosmos-SDK 用于与区块链交互的 Python 客户端库  cosmpy-项目地址\n官方下也有一些示例文档和教程 可参考：https://fetch.ai/docs\n1.2 下载源码并安装依赖\npoetry 的使用\n# 安装brew install poetry    # 这里是mac电脑下安装方式，win可自行查找# 进入项目目录下执行下面命令poetry install # 将根据项目根目录中的pyproject.toml文件中定义的依赖项列表，下载并安装所有必需的依赖项\n\n1.3 调试代码和模块解析aerial模块\n\nconfig.py:\n\n​\t\t核心逻辑是NetworkConfig 和 NetworkConfigError 两个类\n​\t\tNetworkConfig 主要配置 不同网络环境对应的成员数据\n​\t\tvalidator函数主要检查classdata对象成员是否符合规范\n\n\naerial&#x2F;init.py\nLedgerClient 根据config中的URL类型建立一个客户端\n\n\n\n1.4 更改配置后调试测试用例项目测试用例中有一个简单示例：\ncosmospy/tests/integration/test_tx.py::test_faucet_transaction_balance\n\n更改相关配置主要是代币名称，节点地址等，先保证此用例通过\n2.cosmpy实践2.1 找到proto源文件并导入相关依赖改造 cosmos-sdk 项目的 proto 源文件路径一般在根目录下的 proto 文件夹中\n\n需注意 py-proto 是最后生成的Python调用文件，至于其他三个文件都可通过Google下载\n2.2 编译proto文件\n编译命令, 需进入proto路径下，并提前创建py-proto文件夹\n–proto_path&#x3D;.&#x2F;proto         # 指定proto文件的路径\n–python_out&#x3D;.&#x2F;proto&#x2F;py-proto –grpc_python_out&#x3D;.&#x2F;proto&#x2F;py-proto    # 指定Python调用文件路径\n$(find .&#x2F; ( -path “&#x2F;proto&#x2F;“ ) -type f -name “*.proto”)    # 查找proto文件夹下所有 .proto结尾文件\npython -m grpc_tools.protoc --proto_path=./proto --python_out=./proto/py-proto --grpc_python_out=./proto/py-proto $(find ./ \\( -path &quot;*/proto/*&quot; \\) -type f -name &quot;*.proto&quot;) \n\n2.3 生成的文件可能没有包含__init__文件，需要循环创建\n若已经有则可跳过此步骤\n\n\n将 py-proto 文件夹导入cosmpy项目， 重命名为 proto 此时会覆盖旧项目 proto\n\n在proto文件夹下创建__init__.py 文件\n\n循环遍历每个文件夹并创建__init__.py 文件\nfind ./cosmpy/proto/amino  -type d -not -name &#x27;.*&#x27; -exec sh -c &#x27;if [ ! -f &quot;&#123;&#125;/__init__.py&quot; ]; then touch &quot;&#123;&#125;/__init__.py&quot;; fi&#x27; \\;find ./cosmpy/proto/cosmos  -type d -not -name &#x27;.*&#x27; -exec sh -c &#x27;if [ ! -f &quot;&#123;&#125;/__init__.py&quot; ]; then touch &quot;&#123;&#125;/__init__.py&quot;; fi&#x27; \\;\n\n其他文件夹操作方式类似，操作完毕后将得到完整可用的Python客户端调用文件\n\n\n2.4 按proto文件编写对应客户端代码\n","categories":["software-test-collection"],"tags":["software-test","python","cosmos"]},{"title":"02-装饰器","url":"/blog/2023/03/05/software-test-collection/01-10_python%E5%9F%BA%E7%A1%80/02-%E8%A3%85%E9%A5%B0%E5%99%A8/","content":"2.装饰器(decorator)\n本质函数当作参数传递,利用闭包特性实现\n\n2.1 最原始的装饰器def add(*args):    return sum(args)# 把函数当做参数,传递给另外一个函数def new_add(func, *args):    return f&quot;对原函数进行装饰 遵循开放封闭原则: &#123;func(*args)&#125;&quot;print(new_add(add, 1, 2, 3))\n\n\n\n2.2 常见使用方式\n编写一个记录日志 和 统计函数执行耗时的装饰器\n\nimport timedef loger(func):    def wrapper(*args):        print(&quot;1 记录日志的代码...&quot;)        result = func(*args)        print(&quot;2 日志分析的代码...&quot;)        return result    return wrapper# 编写一个计算方法执行耗时的装饰器def timer(func):    def wrapper(*args, **kwargs):        print(&quot;3 计算耗时开始&quot;)        start_time = time.time()        result = func(*args)        end_time = time.time()        print(f&quot;&#123;func.__name__&#125;: 耗时: &#123;end_time - start_time&#125;&quot;)        print(&quot;4 计算耗时结束&quot;)        return result    return wrapper@loger@timerdef add(*args, **kwargs):    return sum(args)print(add(11, 1))  # 执行顺序: 1 -&gt; 3 -&gt; func.__name__耗时 -&gt; 4 -&gt; 2 -&gt; func执行结果\n\n\n\n2.3 装饰器带参数# 编写一个带参数的装饰器，用于验证用户登录def login_verify(is_login=False):  # 这里接收装饰器的参数    def inner(func):  # 接收被装饰的函数        def wrapper(*args, **kwargs):  # 这里接收被装饰函数的参数            if is_login:  # 装饰器的参数在这里使用，用于判断                print(&quot;被装饰函数执行前&quot;)                result = func(*args)                print(&quot;被装饰函数执行后&quot;)                return result            else:                return None        return wrapper  # 返回函数的包装器    return inner@login_verify(is_login=True)def add(*args, **kwargs):    return sum(args)print(add(11, 22))\n\n\n\n2.4 给类添加一个装饰器def class_name(cls):    cls.name = &quot;小明&quot;    return cls# 给类添加装饰器@class_nameclass A(object):    passprint(A.name)\n\n\n\n2.5 使用类编写装饰器class A:    def __init__(self, func):        self.func = func    def __call__(self, *args, **kwargs):        print(&quot;__call__ is running ...&quot;)        return self.func(*args)@A  # 本质 A(add)def add(*args):    return sum(args)print(add(1, 2))\n\n\n\n2.6 使用类编写装饰器带参数class S:    def __init__(self, func, name):        self.func = func        self.name = name    def __call__(self, *args, **kwargs):        print(&quot;类装饰器转入的参数&quot;, self.name)        print(&quot;1 装饰函数执行之前&quot;)        result = self.func(*args)        print(&quot;2 装饰函数执行之后&quot;)        return resultdef add(*args):    return sum(args)s = S(add, &quot;hello&quot;)print(s(1, 3))\n\n","categories":["software-test-collection"],"tags":["software-test","python"]},{"title":"04-魔法方法","url":"/blog/2023/03/07/software-test-collection/01-10_python%E5%9F%BA%E7%A1%80/04-%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/","content":"4.魔法函数4.1 __new__ 、__init__ 、__call __、__del__\n__new__       实例化对象（1.创建对象 2.分配内存）__init__    构造方法,实例化对象时自动调用(1.可以没有 2.如果有方法必须返回None,默认不写return语句)__call __  对象可以被调用时触发执行__del__      析构方法,当对象被回收时触发执行(程序结束、对象引用计数为零称为垃圾时)\n\nclass MyClass(object):    def __init__(self):        print(&quot;__init__ is running...&quot;)    def __new__(cls):        print(&quot;__new__ is running...&quot;)        return super().__new__(cls)  # 创建对象 分配内存    def __call__(self, *args, **kwargs):        print(&quot;__call__ is running...&quot;)    def __del__(self):        print(&quot;__del__ is running...&quot;)MyClass()  # 匿名对象程序并未使用到,执行完后就销毁了print(&quot;----------------------&quot;)a = MyClass()  # 这里会先执行__new__ 在执行 __init__assert hasattr(a, &quot;__del__&quot;)  # Trueprint(callable(a))  # True  可以被调用时结果为True,对象如果没有__call__ 属性则是Falseassert hasattr(lambda x, y: x + y, &quot;__call__&quot;)  # Trueprint(callable(lambda x, y: x + y))  # True\n\n\n\n4.2 __str__ 和 __repr__\n两个方法都只是为了自定义对象的打印信息  \n对象被打印时执行,一般默认先找str, str没有则使用repr\n\nclass A(object):    def __init__(self):        self.name = &quot;李四&quot;    def __str__(self):        print(&quot;__str__ is running ...&quot;)        return &quot;str&quot;    def __repr__(self):        print(&quot;__repr__ is running ...&quot;)        return &quot;&quot;print(A())  # 默认为 &lt;__main__.A object at 0x1043aa710&gt;\n\n\n\n4.3 compare系列class Student:    def __init__(self, age):        self.age = age    def __eq__(self, other):        print(&quot;__eq__ is running ... 可自定义比较逻辑&quot;)        if isinstance(other, Student):            return self.age == other.age  # 返回布尔值        return Falseprint(Student(18) == Student(18))print(Student(18) != 18)  # nq, 不相等的逻辑。如果没有实现，则默认是eq的结果取反。print(dir(Student(18)))  # __lt__、__gt__、__le__、__ge__ 分别表示小于、大于、小于等于和大于等于。\n\n\n\n4.4 attr系列class MyClass(object):    def __init__(self, name, age):        self.name = name        self.age = age    def __getattr__(self, item):        print(&quot;getattr 获取不存在的对象属性时触发&quot;)        # super().__delattr__(item)  # &#x27;MyClass&#x27; object has no attribute &#x27;id&#x27;        return self.__dict__.get(item)    def __setattr__(self, key, value):        print(&quot;setattr 设置修改对象属性时触发&quot;)        super().__setattr__(key, value)    def __delattr__(self, item):        print(&quot;delattr 删除对象属性时触发&quot;)        if item == &quot;name&quot;:  # 属性是name时抛出异常，或者不进行删除操作            # raise AttributeError(&quot;name 属性不让删除...&quot;)            pass        else:            super().__delattr__(item)    def __getattribute__(self, name):        # 访问任何属性（包括存在的和不存在的属性）时都会调用 __getattribute__ 方法        print(&quot;__getattribute__ called&quot;)        return super().__getattribute__(name)a = MyClass(&quot;李四&quot;, 18)  # 每一次给属性赋值 都会执行setattr方法print(a.id)del a.age  # 触发delattr方法print(f&quot;查看对象属性:&#123;a.__dict__&#125;&quot;)\n\n\n\n4.5 item系列# 一个普通对象通过[] 操作取值时会触发 __getitem__class Person(object):    def __setitem__(self, key, value):        print(&quot;setitem []设置值时触发&quot;)        setattr(self, key, value)    def __getitem__(self, item):        print(&quot;getitem []取值时触发&quot;)        return getattr(self, item)    def __delitem__(self, key):        print(&quot;delitem del p[key]时触发&quot;, key)p = Person()p[&#x27;id&#x27;] = 1  # 触发setitem方法print(p[&#x27;id&#x27;])  # 触发getitem方法del p[&#x27;id&#x27;]  # 触发delitem方法\n\n\n\n4.6 __enter__ 和 __exit__\n上下文管理器: 支持”上下文管理协议”的对象,包含 enter() 和 exit() 方法with 可以操作一个 支持上下文管理协议的对象\n\nclass MyOpen:    def __init__(self, file_name: str, mode=&quot;r&quot;):        self.file = open(file_name, mode)    def __enter__(self):        print(&quot;进入with语句块时触发&quot;)        return self.file  # 返回值赋值给 as后面的接收值    def __exit__(self, exc_type, exc_val, exc_tb):        print(&quot;退出with语句块时触发,不论with语句块是否有异常报错，__exit__都会被执行&quot;)        self.file.close()with MyOpen(&quot;test&quot;, &quot;w&quot;) as f:    f.write(&quot;hello world&quot;)\n\n\n\n4.7 __slots__\n该类实例只能创建__slots__中声明的属性，否则报错, 具体作用就是节省内存\n\nfrom memory_profiler import profileclass Test(object):    __slots__ = [&#x27;a&#x27;, &#x27;name&#x27;]    def __init__(self, name):        self.name = nameTest.c = 3  # 类属性仍然可以自由添加t = Test(&quot;xx&quot;)t.a = 1print(t.c)  # 绕过限制就是给类添加属性# t.b = 2  # AttributeError: &#x27;Test&#x27; object has no attribute &#x27;b&#x27;class TestA(object):    __slots__ = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]    def __init__(self, a, b, c):        self.a = a        self.b = b        self.c = cclass TestB(object):    def __init__(self, a, b, c):        self.a = a        self.b = b        self.c = c@profiledef func_02():    temp = [TestA(i, i + 1, i + 2) for i in range(10000)]    del temp    temp = [TestB(i, i + 1, i + 2) for i in range(10000)]    del tempfunc_02()\n\n\n\n4.8 __add__、 __dict__、 __bases__、 __all__\n__add__:  手动实现相加操作__dict__: 获取对象的属性__bases__: 获取类继承的元素__all__: 当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 __all__ 列表中指定的成员\n\nclass MyClass(object):    def __init__(self, value):        self.value = value    def __add__(self, other):        # other这里传入的是第二个对象 obj2  obj2.value ==》 __init__ 初始化中传入的value        return self.value + other.valuea = MyClass(10)print(a + MyClass(20))print(MyClass.__dict__)# __bases__  这是一个元祖，里面的元素是继承的类class A(object):    passprint(A.__bases__)# 当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 `__all__` 列表中指定的成员__all__ = [&quot;MyClass&quot;]\n\n","categories":["software-test-collection"],"tags":["software-test","python"]},{"title":"01-基础数据类型","url":"/blog/2023/03/04/software-test-collection/01-10_python%E5%9F%BA%E7%A1%80/01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"1.基础数据类型1.1 变量赋值和引用\n每定义一个新变量时,就会在内存中开辟一块空间用于数据存储。不同的变量,内存地址是不同的。\n使用 id() 获取内存地址，使用 is 判断变量内存地址是否相同。\n\n\n把一个变量的内存地址同时关联到另一个变量上,称为引用。两个变量对应同一块内存地址\na = 100b = aassert id(a) == id(b)assert a is b\n\n不可变类型变量和可变类型变量在引用时的区别\n常用int、字符串都是不可变类型, 字典、集合、列表都属于可变类型的变量\n# b引用a所指向的数据a = 100b = aassert id(a) == id(b)assert a is ba = 100b = aa = 200print(a, b)  # 200 100assert a is not bassert id(a) != id(b)a1 = &quot;str&quot;b1 = a1a1 = &quot;string&quot;print(a1, b1)  # string stra = [1, 2, 3, 4]b = aa[0] = 100print(a[0], b[0])  # 100, 100assert a is bassert id(a) == id(b)\n\n1.2 小整数池和字符串驻留Python中存在一个小整数池，范围通常在-5到256之间。在这个范围内的整数会被提前创建并缓存，以便节省内存。    \n字符串驻留范围:英文字母、数字、下划线\n以下代码在Ipthon中执行,使用Vscode和PythonCharm执行结果可能不同\n# 在ipython中执行a = 100b = 100print(a is b)  # Truea = 500b = 500print(id(a) == id(b))  # Falsea, b = 500, 500print(a is b) # True 一行定义两个相同值的变量,解释器会优化,a、b是同一内存地址a = &quot;abc&quot;b = &quot;abc&quot;print(a is b)  # Truea = &quot;abc!&quot;b = &quot;abc!&quot;print(a is b)  # False\n\n\n\n1.3 数据类型数值: int float bool complex(复数)序列: str list tuple散列: set dict  \n\n常见基础面试题\n\n列表去重方案\n# 方案一  set() 利用集合去重的特性original_list = [1, 2, 3, 4, 3, 2, 1]deduplicated_list = list(set(original_list))print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案二  使用enumerate 找到列表下标判断元素是否存在deduplicated_list = [x for i, x in enumerate(original_list) if x not in original_list[:i]]print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案三  使用 dict.fromkeys():利用字典的键的唯一性deduplicated_list = list(dict.fromkeys(original_list))print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案四  使用 Counter 是 collections 模块提供的一个计数器对象，可以用来统计元素出现的次数deduplicated_list = list(Counter(original_list)) # Counter(&#123;1: 2, 2: 2, 3: 2, 4: 1&#125;)print(deduplicated_list)  # 输出: [1, 2, 3, 4]\n\n字符串反转\nprint(&quot;第一种方式:&quot;, &quot;&quot;.join(reversed(data)))print(&quot;第二种方式:&quot;, data[::-1])\n\n\n推导式\nlist推导式\nresult = [&quot;data&#123;&#125;&quot;.format(i) for i in range(0, 100) if i % 2 == 0]\n\ndict 推导式\nprint(&#123;f&quot;data&#123;(i + 1)&#125;&quot;: i + 1 for i in range(3)&#125;)  # &#123;&#x27;data1&#x27;: 1, &#x27;data2&#x27;: 2, &#x27;data3&#x27;: 3&#125;\n\nset 推导式\n&#123; expression for item in Sequence if conditional &#125;\n\ntuple 推导式 （生成器表达式）\na = (x for x in range(1,10))  # &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;  生成器对象tuple(a)  # 使用 tuple() 函数，可以直接将生成器对象转换成元组\n\n1.4 collections\n 这个模块实现了一些专门化的容器，提供了对 Python 的通用内建容器 dict、list、set 和 tuple 的补充。\n\nfrom collections import namedtuple, deque, ChainMap# namedtuple 命名元祖Student = namedtuple(&#x27;Students&#x27;, [&quot;name&quot;, &quot;age&quot;, &#x27;index&#x27;])tu1 = Student(name=&quot;张三&quot;, age=18, index=1)print(tu1.name)  # 张三print(isinstance(tu1, tuple))  # True 也是元祖类型数据print(type(tu1))  # tu1数据类型 &lt;class &#x27;__main__.Students&#x27;&gt; Student对象# deque 双端队列d = deque(&#x27;ghi&#x27;)d.extendleft(&#x27;123&#x27;, )d.appendleft(&#x27;4&#x27;)print(d)   # deque([&#x27;4&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;])# ChainMap 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图dict1 = &#123;&#x27;music&#x27;: &#x27;bach&#x27;, &#x27;art&#x27;: &#x27;rembrandt&#x27;&#125;dict2 = &#123;&#x27;art&#x27;: &#x27;van gogh&#x27;, &#x27;opera&#x27;: &#x27;carmen&#x27;&#125;dict3 = &#123;&#x27;opera&#x27;: &#x27;dict3&#x27;, &#x27;test&#x27;: &#x27;dict3&#x27;&#125;c = ChainMap(dict1, dict2, dict3)# 获取map中的key和其传入参数有关系, 迭代顺序是通过从后往前扫描print(c.get(&#x27;art&#x27;), c.get(&#x27;opera&#x27;))  # rembrandt, carmen# 如果要实现dict.update功能,可以使用update()c.update(dict3)print(c.get(&#x27;art&#x27;), c.get(&#x27;opera&#x27;))  # rembrandt, dict3\n\n\n\n1.5 iterable可迭代对象: 可被 for 遍历都是可迭代对象  \n\n实现了 iter 方法，并且该方法返回一个迭代器对象。  \n实现了 getitem 方法，并且可以通过索引访问元素。\n\n\nclass collections.abc.Iterable\n提供了 __iter__() 方法的抽象基类。\n使用 isinstance(obj, Iterable) 可以检测一个类是否已经注册到了 Iterable 或者实现了 __iter__() 函数，但是无法检测这个类是否能够使用 __getitem__() 方法进行迭代。检测一个对象是否是 iterable 的唯一可信赖的方法是调用 iter(obj)。\n\n示例1: 实现 __iter__ 但是返回一个list 非迭代器对象  \nclass Iterable1:    def __init__(self):        self.data = [1, 2, 3, 4]    def __iter__(self):        # 返回的是一个列表,而不是一个迭代器对象        return self.dataobj1 = Iterable1()assert isinstance(obj1, Iterable)  # Trueassert iter(obj1)  # iter() returned non-iterator of type &#x27;list&#x27;\n\n示例2: 实现 __iter__ 返回一个迭代器对象  \nclass Iterable2:    def __init__(self):        self.data = [1, 2, 3, 4]    def __iter__(self):        # 返回的是一个迭代器对象        return iter(self.data)obj2 = Iterable2()  # obj2 是可以被for遍历的对象print(iter(obj2)) # &lt;list_iterator object at 0x1043bb6d0&gt;\n\n示例3: 实现 __getitem__ 访问元素  \nclass Iterable3:    def __init__(self):        self.data = [1, 2, 3, 4, 5]    def __getitem__(self, index):        # 通过索引访问元素，实现迭代行为        return self.data[index]my_iterable = Iterable3()print(iter(my_iterable))\n\n\n\n1.6 iterator迭代器:必须要同时拥有 __iter__ 和 __next__ 方法才是迭代器\n\n迭代器调用 __next__ 方法会调用迭代器中的下一个值\n\n示例1:通过 iter(iterable) 得到迭代器\nmy_iterator = iter([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])# hasattr 判断某个对象是否包含某个属性信息print(hasattr(my_iterator, &quot;__iter__&quot;))  # Trueprint(hasattr(my_iterator, &quot;__next__&quot;))  # True\n\n示例2:实现一个迭代器，必须要实现 __next__ 和 __iter__ 方法\n\n示例中并没有手动实现 __iter__ 会使用父类的 __iter__ \n\nfrom typing import Iteratorclass Students(Iterator):    def __init__(self):        self.students = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]        self.index = 0    def __next__(self):        if self.index &gt;= len(self.students):            raise StopIteration        self.index += 1        return self.students[self.index - 1]print(isinstance(Students(), Iterator))  # Trueprint(my_iterator.__iter__())  # &lt;__main__.Students object at 0x1009a7950&gt;for item in Students():    print(item)  \n\n示例3:实现一个迭代器，自己实现 __init__ 方法\nclass Students2(Iterator):    def __init__(self):        self.students = [&quot;1&quot;, &quot;2&quot;]        self.index = 0    def __iter__(self):        return iter(self.students)    def __next__(self):        if self.index &gt;= len(self.students):            raise StopIteration        self.index += 1        return self.students[self.index - 1]my_iterator2 = Students2()print(my_iterator2.__iter__())  # &lt;list_iterator object at 0x104f37fd0&gt;print(isinstance(my_iterator2, Iterator))  # Trueprint(next(my_iterator2))  # 1print(next(my_iterator2))  # 2print(next(my_iterator2))  # raise StopIteration\n\n示例4:实现一个 range 迭代器\n\n\nrange 方法的签名 start、stop 两个参数\n__iter__ 方法要求返回值必须是一个”迭代器“ (或者返回值必须要有 __next__ 方法)\n\n\nclass Next:    def __init__(self, stop, start=-1):        self.start = start        self.stop = stop    def __next__(self):        if self.start &gt;= self.stop - 1:            raise StopIteration        self.start += 1        return self.startclass MyRange:    def __init__(self, stop):        self.stop = stop    def __iter__(self):        return Next(self.stop)my_range = MyRange(5)  # &lt;__main__.MyRange object at 0x1045029d0&gt;# False 断言它不是一个迭代器,但是它可以被for遍历,所以__iter__返回值有__next__方法也可以print(isinstance(my_range, Iterator)) for item in my_range:    print(item)  # 也可以通过 for 遍历\n\n示例5: 基于MyRange使用while实现for \n\nfor 会自动调用 __iter__ , __next__ 方法,但是while不会,需要手动调用\n\n# 基于MyRange使用while实现fordef my_while():    start, stop = 0, 5    my_range = MyRange(stop)    numbers = my_range.__iter__()  # 手动调用__iter__方法    while start &lt; stop:        print(numbers.__next__())        start += 1my_while()\n\n\n\n1.7 generator生成器(高效):生成器是特殊的迭代器,迭代器是特殊的可迭代对象,那么生成器必定是可迭代对象\n\n使用yield关键字返回一个生成器对象\n\nfrom typing import Iterable, Iteratordef g_func2():    my_list = range(3)    for i in my_list:        yield i * ig = g_func2()print(isinstance(g, Iterable))  # Trueprint(g.__iter__())  # &lt;generator object g_func1 at 0x10271fc10&gt;print(next(g))print(next(g))print(next(g))print(hasattr(g, &quot;__iter__&quot;))  # Trueprint(hasattr(g, &quot;__next__&quot;))  # Trueprint(isinstance(g, Iterator))  # True\n\n\n\n1.8 for循环的本质\n\n调用iter()，将numbers转化为迭代器numbers_iterator\n调用next(numbers_iterator)，返回出numbers的第一个元素\n循环步骤2,迭代完numbers内所有数据,捕获异常\n\n\n# while + iteratornumbers = [1, 2, 3, 4]numbers_iterator = iter(numbers)while True:    try:        print(next(numbers_iterator))    except StopIteration:  # 捕捉异常终止循环        break# for循环for i in numbers:    print(i)\n\n\n\n1.9 itertools\n为高效循环而创建迭代器的函数\n\niterable = itertools.chain([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;])for i in iterable:    print(i)  # --&gt; A B C D E Ffrom_iterable = itertools.chain.from_iterable([&#x27;ABC&#x27;, &#x27;DEF&#x27;])for i in from_iterable:    print(i)r = itertools.combinations(&quot;ABCD&quot;, 2)for i in r:    print(i)  # --&gt; AB AC AD BC BD CD\n\n\n\n1.10 lambda、map、zip\nlamdba 处理简单业务逻辑\ny: any = lambda x: x + 1print(y(10))Students = [    &#123;&quot;name&quot;: &quot;a&quot;, &quot;age&quot;: 18&#125;,    &#123;&quot;name&quot;: &quot;c&quot;, &quot;age&quot;: 20&#125;,    &#123;&quot;name&quot;: &quot;b&quot;, &quot;age&quot;: 19&#125;,    &#123;&quot;name&quot;: &quot;ca&quot;, &quot;age&quot;: 19&#125;,    &#123;&quot;name&quot;: &quot;cb&quot;, &quot;age&quot;: 19&#125;]# 根据age排序,age一致时根据name排序print(sorted(Students, key=lambda student: (student[&quot;age&quot;], student[&quot;name&quot;])))\n\nmap(func, *iterables) –&gt; map object\n# map 可迭代对象元素合并 返回新的map对象,按最短的对象合并a = [1, 2, 3]b = [4, 5, ]# map(func, *iterables)# func --&gt; lambda a1, b1: (a1, b1)# *iterables --&gt; a, bnum1 = map(lambda a1, b1: (a1, b1), a, b)  # &lt;map object at 0x109efed60&gt;for i in num1:    print(i)  # (1, 4), (2, 5)\n\nreduce 求和\nfrom functools import reduceprint(reduce(lambda x, y: x + y, range(1, 101)))  # 5050\n\nfilter 过滤\nprint(list(filter(lambda x: x &gt; 5, range(10))))  # &lt;filter object at 0x106ad6c40&gt;\n\nzip\na = [1, 2, 3]b = [4, 5, 6, 7, 8]print(list(zip(a, b)))  # [(1, 4), (2, 5), (3, 6)]  # 元素个数与最短的列表一致\n\n1.11 namespace\n一般有三种命名空间:\n\n内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。\n全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。\n局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）\n\n\nPython的作用域一共有4种【规则顺序: L –&gt; E –&gt; G –&gt; gt; B】\n\nL（Local）:最内层，包含局部变量，比如一个函数&#x2F;方法内部。\n\nE（Enclosing）:包含了非局部(non-local)也非全局(non-global)的变量。\n比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。\n\nG（Global）:当前脚本的最外层，比如当前模块的全局变量。\n\nB（Built-in）: 包含了内建的变量&#x2F;关键字等。最后被搜索\n\n\n\n闭包\n\n1.在一个函数内部定义了另一个函数2.内部函数引用了外部函数的变量\n\ng_count = 0  # 全局作用域def outer():    o_count = 1  # 闭包函数外，函数中    print(f&quot;Enclosing: &#123;o_count&#125;&quot;)    def inner():        i_count = 2  # 局部作用域        print(f&quot;Local: &#123;i_count&#125;&quot;)        nonlocal o_count  # 外层作用域        o_count += 5        print(f&quot;Enclosing: &#123;o_count&#125;&quot;)    return inner  # 返回函数名称 可以被调用print(f&quot;Global: &#123;g_count&#125;&quot;)  # Global: 0func = outer()  # Enclosing: 1func()  # Local: 2 Enclosing: 6func()  # Local: 2 Enclosing: 11\n\n1.12 private_name# import 私有变量# 1. __name它不会被导入到导入模块的命名空间中# 2. _name会被导入到导入模块的命名空间中class MyClass:    def __init__(self):        self.__name = &quot;Private Name&quot;  # 私有变量 __name        self._name = &quot;Conventionally Private Name&quot;  # 约定上的私有变量 _name    def get_private_name(self):        return self.__name    def get_conventionally_private_name(self):        return self._nameobj = MyClass()# 访问私有变量 __nameprint(obj.get_private_name())  # 输出: Private Name# print(obj.__name)  # 错误，在类外部，无法直接访问私有变量，会引发 AttributeError 错误print(obj._MyClass__name)  # 输出: Private Name，通过名称重整方式访问私有变量# 访问约定上的私有变量 _nameprint(obj.get_conventionally_private_name())  # 输出: Conventionally Private Nameprint(obj._name)  # 输出: Conventionally Private Name，可以直接访问约定上的私有变量\n","categories":["software-test-collection"],"tags":["software-test","python"]},{"title":"00-区块链基础","url":"/blog/2024/05/08/blockchain/0-base/00-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/","content":"\n文章将使用问答的形式进行区块链基础知识的讲解，同时满足学习和面试需求\n\n1.什么是区块链？区块链是一种分布式的、去中心化的数字账本技术，用于记录和验证交易与数据。区块链的核心概念是将交易和数据记录在一个被称为”区块”的数据结构中，并通过加密和共识算法保证数据的安全性和一致性。每个区块包含了一批交易的信息，以及与之前区块的链接，形成了一个链式结构。\n2.区块链有什么特点？在区块链中，参与者通过网络共享和维护这个账本的副本，而不是依赖于中央机构来验证交易。这种去中心化的特性使得区块链具有以下特点：\n\n透明性：区块链中的交易和数据是公开可见的，任何人都可以查看账本的副本。这提供了一种透明的方式来验证交易和监督系统的运作。\n安全性：区块链使用密码学技术对数据进行加密和验证，从而确保数据的安全性和完整性。由于数据存储在多个节点上，篡改数据变得非常困难。\n去中心化：区块链没有中央机构或控制权，参与者通过共识算法来达成对账本的一致认可。这使得区块链具有更高的可信度和抗攻击能力。\n不可篡改性：一旦数据被记录在区块链上，由于每个区块都包含了前一个区块的哈希值，任何对数据的篡改都将被其他节点检测到。\n\n3.区块链的运作方式3.1 哈希函数理想的加密哈希函数具备5个主要属性：\n\n确定性：相同的消息总是产生相同的哈希值。\n快速：快速计算任何给定消息的哈希值。\n抵抗性：除非尝试所有可能的消息，否则从其哈希值生成消息是不可行的。\n不相关：对消息的微小更改会极大地改变哈希值，以至于新值与旧值没有关系。\n抗碰撞：不可能找到具有相同哈希值的两个不同消息。\n\n3.2 区块、链\n有效区块是一组有序的交易。\n每个块都包含前一个块的哈希值。 \n区块的哈希值具有易证明难伪造。\n\n区块链接方式如下图示例：\n\n\n4.交易的运作方式4.1 加密钱包\n钱包并不存储加密资产，它们只存储私钥\n\n先理解三个重要概念：\n\n私钥、公钥、地址：公私钥通过非对称加密生成，公钥用于分发，私钥用于个人保留，地址通过公钥推导\n加密与解密：消息传递通过公钥加密、私钥解密\n签名与验证：交易信息通过私钥签名、公钥验证签名\n\n\n\n4.2 以BTC为例，讲解一笔交易流程\n用户B转账 1 bitcoin 至用户A\n\n\n\n\n用户B使用自己的私钥签名完成交易信息【确认用户B有足够的代币】\n将交易信息发送至节点，节点使用公钥验证交易信息，并存储在内存池中。\n节点将交易分组在区块中，并广播到其他节点。\n共识成功并出块后，用户A才能获取到1 bitcoin。\n\n5.共识5.1 工作量证明（PoW）\n去中心化程度高，消耗资源高在 PoW 共识中，用户必须完成任意难度的任务，当与块中的有序交易结合时，会产生符合特定标准的哈希函数结果。\n\n\n称为“矿工”的节点通过暴力竞争来解决数学问题（找到特定规则的哈希值）\n第一个解决问题的矿工可以创建一个区块\n其他节点检查该块是否有效。如果是，矿工将获得加密货币奖励。如果不是，矿工就浪费了时间和精力。\n所有的节点都将新块添加到其区块链副本中。\n\n5.2 股权证明 (PoS)\n去中心化的一种妥协方案，更像选择代表人参与网络，相比工作量证明大大降低资源消耗\n\n\n称为验证者节点会抵押一些加密货币。投入一定数量的加密货币来参与和分配出块奖励。\n验证者节点所占的权重越高更有可能被选择来处理交易并创建区块。\n其他验证者节点检查该块是否有效。如果是，所有参与的验证者都会赚取收益。如果不是，创建该块的验证者可能会失去其权益或者获得惩罚。\n\n还有其他共识算法将后续介绍，比如：权威证明、委托权益证明等\n","categories":["blockchain-collection"],"tags":["blockchain"]},{"title":"03-对象","url":"/blog/2023/03/06/software-test-collection/01-10_python%E5%9F%BA%E7%A1%80/03-%E5%AF%B9%E8%B1%A1/","content":"3.面向对象3.1 三大特性\n面向对象三大特性:继承 封装 多态\n\n# 面向对象三大特性:继承 封装 多态class Base(object):    def __init__(self):        self.leg = &quot;4&quot;    def func1(self):        print(f&quot;Base 有 &#123;self.leg&#125; 条腿...&quot;)class Cat(Base):    def func1(self):        print(f&quot;我是cat,有&#123;self.leg&#125;条腿...&quot;)        print(&quot;我会上树&quot;)class Dog(Base):    def func1(self):        print(f&quot;我是dog,有&#123;self.leg&#125;条腿...&quot;)        print(&quot;我跑得快&quot;)class Table(Base):    def func1(self):        print(f&quot;我是一个餐桌，也有&#123;self.leg&#125;条腿，但我不会跑...&quot;)def func(arg):    arg.func1()func(Base())func(Dog())func(Cat())func(Table())\n\n\n\n3.2 类方法和静态方法\nclassmethod 给类定义的方法staticmethod 目的只是封装在一起,内聚\n\nclass Person(object):    def __init__(self, name):        self.name = name    @classmethod    def name(cls, name):        return cls(name)    @staticmethod    def age(age: int):        return age    def __repr__(self):        return self.namea = Person(name=&quot;张三&quot;)print(a)b = Person.name(&quot;李四&quot;)print(b)print(a.age(18))  # 对象可以调用print(Person.age(20))  # 类也可以调用\n\n\n\n3.3 property装饰器\n1.将函数属性伪装成数据属性2.统一数据属性的查、改、删操作\n\nclass Person:    def __init__(self, name):        self.__name = name    @property    def name(self):        return self.__name    # 当name 遇到赋值操作, 即 = 时触发被property.setter装饰的函数的执行    @name.setter    def name(self, value):        self.__name = value    # 当name 遇到删除操作，即 del 时触发property.deleter装饰的函数的执行    @name.deleter    def name(self):        print(&#x27;deleter&#x27;)obj1 = Person(&#x27;abc&#x27;)print(obj1.name)obj1.name = &#x27;aaa&#x27;print(obj1.name)del obj1.name\n\n\n\n3.4 cached_property\n相比 property 增加缓存功能,针对不可变的高计算资源消耗的实例特征属性\n\nfrom functools import cached_property  # 内置 3.8版本才加入的cached_propertypip3 install cached-property  # 第三方包 支持asyncio\n\n\n\n3.5 属性查找顺序\n对象 —&gt;   父类   —&gt;    继承类,  依次类推,找不到则报错\n\n3.6 多继承\n多继承的优点:同时继承多个父类属性和方法，功能强大。\n多继承缺点:代码可读性变差。\n通过类的mro()方法查看多继承的查找顺序。\n__bases__ 可以查看类继承的所有父类\n\nprint(C.mro())# [&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]print(C.__bases__)  # (&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;)\n\n\n\n3.7 广度优先和深度优先# [&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.A1&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]# python3中全部默认继承object，所以都是新式类- object类提供了一些常用内置方法的实现,如用来在打印对象时返回字符串的内置方法__str__新式类:广度优先obj -&gt; &lt;class &#x27;__main__.C&#x27;&gt; -&gt; &lt;class &#x27;__main__.A1&#x27;&gt; ... -&gt; &lt;class &#x27;object&#x27;&gt;\n\n\n\n3.8 抽象基类\n1.抽象类本身不能实例化\n2.子类必须实现其定义接口\n\nimport abc# 指定metaclass属性将类设置为抽象类，抽象类本身不能实例化class Animal(metaclass=abc.ABCMeta):    @abc.abstractmethod  # 该装饰器限制子类必须定义有一个名为talk的方法    def talk(self):  # 抽象方法中无需实现具体的功能        passclass Cat(Animal):  # 但凡继承Animal的子类都必须遵循Animal规定的标准    def talk(self):  # 必须定义talk方法\t\t\t\t\t\t        passcat = Cat()  # 若子类中没有一个定义talk的方法则会抛出异常TypeError，无法实例化\n\n\n\n3.9 isinstance 和 issubclassprint(isinstance(a, int))  # 断言类型print(issubclass(People, Animal))   # 断言是否其子类\n\n\n\n3.10 动态获取对象信息(反射)hasattr(obj, &#x27;x&#x27;)\t                    # 判断对象是否有一个属性，返回布尔值getattr(object, name, default=None)\t  # 获取对象的name属性，name属性不存在的返回Nonesetattr(x, &#x27;y&#x27;, &#x27;v&#x27;)\t       # 更新x对象 y属性的值, 等价于 x.y = &#x27;v&#x27;，当y不存在的新增delattr(x, &#x27;y&#x27;)\t\t           # 删除x对象 y属性, 等价于 del x.y   属性y不存在则报错\n","categories":["software-test-collection"],"tags":["software-test","python"]}]