[{"title":"00-开篇","url":"/blog/2024/05/10/software-test-collection/00-%E5%BC%80%E7%AF%87/","content":"1.初衷在职场中迷茫是常见的经历，为了激励自己继续前行，总结过往经历并进行优化是一个不错的做法。\n关于软件测试的经历，带着问题去实践寻找答案：\n\n目标与动机：最初选择这个行业的动机是什么？目标是什么？\n有两句话一直警示着我，在此分享给大家\n\n如果建筑工人盖房子的方式跟程序员写程序一样，那第一只飞来的啄木鸟就将毁掉人类文明\n软件测试的价值在于将原本暴露在用户面前的缺陷，提前在内部发现并解决\n\n\n\n​\t\t然后基于很多项目或公司实际情况，不能说测试无用但是收益甚微【在小公司尤其明显】，存在的问题可能是多种多样的，一方面和企业对质量的重视程度，一方面和测试人员本身技能都有关系。\n\n技能与知识：技能和知识主要是为了解决实际问题而出发\n比如常见的接口测试，需要掌握一些接口调试工具：postman、curl等\n手动测试进度很慢就需要引入自动化，比如掌握一些编程语言和发请求的库，针对业务场景结合就能完成\n对于性能有需求，就需要掌握一些压测工具，特定场景下工具无法解决问题，就在多掌握一门高性能编程语言，本质还是在处理一些请求的问题\n多分布式系统重点关注一些数据一致性的解决方案，从理解共识算法开始更容易发现应用层的错误，以及发现错误后能推理出在哪里出了问题\n\n\n\n技能终究是工具，掌握多样化的工具是为了在解决问题时提供解决方案，去做别人不可替代的事才有价值。\n2.软测基本三阶段\n入门、初级\n入门不难，周期短，一般计算机专业的学生对于软件开发有一定经验，通过三个月的自学也能达到岗位需求\n技术栈比较浅，特别是在当前市场环境下，不推荐入坑\n\n\n中、高级\n需要至少熟悉一个特长，目前市场上的需求对于 自动化测试、性能测试需求，一般需要掌握至少一门编程语言，有一些测试平台的开发经验更佳\n其实对于这种岗位也没有太多技术含量，大部分还是api调用工程师，有专岗的自动化工作还是比较能沉下心去学习，在持续的学习中接触到更多的知识才会发现自己掌握的只是冰山一角\n高级测试很多也只是编写维护自动化而已，自动化能解决一些问题，也会带来问题\n什么时候要自动化？如何自动化？自动化程序如何，全部还是部分\n维护的成本也不能忽视，为了测试程序招了比开发还水的团队维护着大量的测试代码，这本就是一个伪命题\n\n\n测试开发岗、对于大厂而言还有精力和能力去打磨高效的测试平台，其要求能力需对标打开。\n除开内部自研的系统外，目前并没有明星产品的推出能做到一统天下，各系统不同关注点都需要编写代码去实现\n可以推荐两个平台关注下：\nRunnerGo go 微服务开发技术栈，一款全栈式测试平台\nMeterSphere java 技术栈，兼容JMter， 一站式开源持续测试平台\n\n\n\n\n\n\n资深、专家、测试管理\n某特定场景下能提供完整解决方案，拿人钱财替人消灾。\n代码审计，软件架构，优化方案，解决核心的能力提高了自然会成为所谓的专家\n有了架构师，所谓测试架构师存在的意义又是什么呢？\n\n\n\n3.改变在步入web3行业后，工作中发现在此领域中大家对于软件的质量尤其关注，特别是智能合约\n测试经验在智能合约开发中是尤为重要的一部分，web3领域对于安全的缺口也很大\n4.总结\n要做软测知识汇总，以实际工作为主，做实践项目输出\n主要帮助的人群是长期功能测试的同学提升竞争力\n\n要学习web3并形成个人的知识体系，并培养自己在web3行业的竞争力\n除了个人需要较强的自制力外，还需要寻找一个团队组队，以交流促进学习并相互监督\n\n选对路比盲目努力重要\n首先要相信选择的路是有希望的，才能坚持学下去，目标先掌握rust，因为上山的路并不拥挤\n\n\n\n共勉。\n","categories":["software-test-collection"],"tags":["software-test"]},{"title":"00-区块链基础","url":"/blog/2024/05/08/blockchain/base/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/","content":"","categories":["blockchain-collection"],"tags":["blockchain"]},{"title":"投资笔记","url":"/blog/2024/04/24/diary/note/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/","content":"韭菜的自我修养\nA股就是屎一样市场【big shit market】今天清空了所有定投买入的基金，如葛x的医疗股中下跌幅度高达56%,还定投个锤子白酒也迟迟萎靡不振，全部割肉割肉，留给有需要的人吧\n\n大A就是垃圾市场，股票基金都一样，没有区别\n\n全面转战加密，又找不到自己核心的竞争力，需要静下来整理下突破的方向和短期要达到的目标\n\n\n","tags":["note"]},{"title":"python-基础复习","url":"/blog/2023/08/09/python/base/py-01%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","content":"1.基础知识1.1 变量赋值和引用\n每定义一个新变量时,就会在内存中开辟一块空间用于数据存储。不同的变量,内存地址是不同的。\n使用 id() 获取内存地址，使用 is 判断变量内存地址是否相同。\n\n\n把一个变量的内存地址同时关联到另一个变量上,称为引用。两个变量对应同一块内存地址\na = 100b = aassert id(a) == id(b)assert a is b\n\n不可变类型变量和可变类型变量在引用时的区别\n常用int、字符串都是不可变类型, 字典、集合、列表都属于可变类型的变量\n# b引用a所指向的数据a = 100b = aassert id(a) == id(b)assert a is ba = 100b = aa = 200print(a, b)  # 200 100assert a is not bassert id(a) != id(b)a1 = &quot;str&quot;b1 = a1a1 = &quot;string&quot;print(a1, b1)  # string stra = [1, 2, 3, 4]b = aa[0] = 100print(a[0], b[0])  # 100, 100assert a is bassert id(a) == id(b)\n\n1.2 小整数池和字符串驻留Python中存在一个小整数池，范围通常在-5到256之间。在这个范围内的整数会被提前创建并缓存，以便节省内存。    \n字符串驻留范围:英文字母、数字、下划线\n以下代码在Ipthon中执行,使用Vscode和PythonCharm执行结果可能不同\n# 在ipython中执行a = 100b = 100print(a is b)  # Truea = 500b = 500print(id(a) == id(b))  # Falsea, b = 500, 500print(a is b) # True 一行定义两个相同值的变量,解释器会优化,a、b是同一内存地址a = &quot;abc&quot;b = &quot;abc&quot;print(a is b)  # Truea = &quot;abc!&quot;b = &quot;abc!&quot;print(a is b)  # False\n\n\n1.3 数据类型数值: int float bool complex(复数)序列: str list tuple散列: set dict  \n\n常见基础面试题\n\n列表去重方案\n# 方案一  set() 利用集合去重的特性original_list = [1, 2, 3, 4, 3, 2, 1]deduplicated_list = list(set(original_list))print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案二  使用enumerate 找到列表下标判断元素是否存在deduplicated_list = [x for i, x in enumerate(original_list) if x not in original_list[:i]]print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案三  使用 dict.fromkeys():利用字典的键的唯一性deduplicated_list = list(dict.fromkeys(original_list))print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案四  使用 Counter 是 collections 模块提供的一个计数器对象，可以用来统计元素出现的次数deduplicated_list = list(Counter(original_list)) # Counter(&#123;1: 2, 2: 2, 3: 2, 4: 1&#125;)print(deduplicated_list)  # 输出: [1, 2, 3, 4]\n\n字符串反转\nprint(&quot;第一种方式:&quot;, &quot;&quot;.join(reversed(data)))print(&quot;第二种方式:&quot;, data[::-1])\n\n\n推导式\nlist推导式\nresult = [&quot;data&#123;&#125;&quot;.format(i) for i in range(0, 100) if i % 2 == 0]\n\ndict 推导式\nprint(&#123;f&quot;data&#123;(i + 1)&#125;&quot;: i + 1 for i in range(3)&#125;)  # &#123;&#x27;data1&#x27;: 1, &#x27;data2&#x27;: 2, &#x27;data3&#x27;: 3&#125;\n\nset 推导式\n&#123; expression for item in Sequence if conditional &#125;\n\ntuple 推导式 （生成器表达式）\na = (x for x in range(1,10))  # &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;  生成器对象tuple(a)  # 使用 tuple() 函数，可以直接将生成器对象转换成元组\n\n1.4 collections\n 这个模块实现了一些专门化的容器，提供了对 Python 的通用内建容器 dict、list、set 和 tuple 的补充。\n\nfrom collections import namedtuple, deque, ChainMap# namedtuple 命名元祖Student = namedtuple(&#x27;Students&#x27;, [&quot;name&quot;, &quot;age&quot;, &#x27;index&#x27;])tu1 = Student(name=&quot;张三&quot;, age=18, index=1)print(tu1.name)  # 张三print(isinstance(tu1, tuple))  # True 也是元祖类型数据print(type(tu1))  # tu1数据类型 &lt;class &#x27;__main__.Students&#x27;&gt; Student对象\n\n# deque 双端队列d = deque(&#x27;ghi&#x27;)d.extendleft(&#x27;123&#x27;, )d.appendleft(&#x27;4&#x27;)print(d)   # deque([&#x27;4&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;])\n\n# ChainMap 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图dict1 = &#123;&#x27;music&#x27;: &#x27;bach&#x27;, &#x27;art&#x27;: &#x27;rembrandt&#x27;&#125;dict2 = &#123;&#x27;art&#x27;: &#x27;van gogh&#x27;, &#x27;opera&#x27;: &#x27;carmen&#x27;&#125;dict3 = &#123;&#x27;opera&#x27;: &#x27;dict3&#x27;, &#x27;test&#x27;: &#x27;dict3&#x27;&#125;c = ChainMap(dict1, dict2, dict3)# 获取map中的key和其传入参数有关系, 迭代顺序是通过从后往前扫描print(c.get(&#x27;art&#x27;), c.get(&#x27;opera&#x27;))  # rembrandt, carmen# 如果要实现dict.update功能,可以使用update()c.update(dict3)print(c.get(&#x27;art&#x27;), c.get(&#x27;opera&#x27;))  # rembrandt, dict3\n\n\n\n1.5 iterable可迭代对象: 可被 for 遍历都是可迭代对象  \n\n实现了 iter 方法，并且该方法返回一个迭代器对象。  \n实现了 getitem 方法，并且可以通过索引访问元素。\n\n\nclass collections.abc.Iterable\n提供了 __iter__() 方法的抽象基类。\n使用 isinstance(obj, Iterable) 可以检测一个类是否已经注册到了 Iterable 或者实现了 __iter__() 函数，但是无法检测这个类是否能够使用 __getitem__() 方法进行迭代。检测一个对象是否是 iterable 的唯一可信赖的方法是调用 iter(obj)。\n\n示例1: 实现 __iter__ 但是返回一个list 非迭代器对象  \nclass Iterable1:    def __init__(self):        self.data = [1, 2, 3, 4]    def __iter__(self):        # 返回的是一个列表,而不是一个迭代器对象        return self.dataobj1 = Iterable1()assert isinstance(obj1, Iterable)  # Trueassert iter(obj1)  # iter() returned non-iterator of type &#x27;list&#x27;\n\n示例2: 实现 __iter__ 返回一个迭代器对象  \nclass Iterable2:    def __init__(self):        self.data = [1, 2, 3, 4]    def __iter__(self):        # 返回的是一个迭代器对象        return iter(self.data)obj2 = Iterable2()  # obj2 是可以被for遍历的对象print(iter(obj2)) # &lt;list_iterator object at 0x1043bb6d0&gt;\n\n示例3: 实现 __getitem__ 访问元素  \nclass Iterable3:    def __init__(self):        self.data = [1, 2, 3, 4, 5]    def __getitem__(self, index):        # 通过索引访问元素，实现迭代行为        return self.data[index]my_iterable = Iterable3()print(iter(my_iterable))\n\n\n\n1.6 iterator迭代器:必须要同时拥有 __iter__ 和 __next__ 方法才是迭代器\n\n迭代器调用 __next__ 方法会调用迭代器中的下一个值\n\n示例1:通过 iter(iterable) 得到迭代器\nmy_iterator = iter([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])# hasattr 判断某个对象是否包含某个属性信息print(hasattr(my_iterator, &quot;__iter__&quot;))  # Trueprint(hasattr(my_iterator, &quot;__next__&quot;))  # True\n\n示例2:实现一个迭代器，必须要实现 __next__ 和 __iter__ 方法\n\n示例中并没有手动实现 __iter__ 会使用父类的 __iter__ \n\nfrom typing import Iteratorclass Students(Iterator):    def __init__(self):        self.students = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]        self.index = 0    def __next__(self):        if self.index &gt;= len(self.students):            raise StopIteration        self.index += 1        return self.students[self.index - 1]print(isinstance(Students(), Iterator))  # Trueprint(my_iterator.__iter__())  # &lt;__main__.Students object at 0x1009a7950&gt;for item in Students():    print(item)  \n\n示例3:实现一个迭代器，自己实现 __init__ 方法\nclass Students2(Iterator):    def __init__(self):        self.students = [&quot;1&quot;, &quot;2&quot;]        self.index = 0    def __iter__(self):        return iter(self.students)    def __next__(self):        if self.index &gt;= len(self.students):            raise StopIteration        self.index += 1        return self.students[self.index - 1]my_iterator2 = Students2()print(my_iterator2.__iter__())  # &lt;list_iterator object at 0x104f37fd0&gt;print(isinstance(my_iterator2, Iterator))  # Trueprint(next(my_iterator2))  # 1print(next(my_iterator2))  # 2print(next(my_iterator2))  # raise StopIteration\n\n示例4:实现一个 range 迭代器\n\n\nrange 方法的签名 start、stop 两个参数\n__iter__ 方法要求返回值必须是一个”迭代器“ (或者返回值必须要有 __next__ 方法)\n\n\nclass Next:    def __init__(self, stop, start=-1):        self.start = start        self.stop = stop    def __next__(self):        if self.start &gt;= self.stop - 1:            raise StopIteration        self.start += 1        return self.startclass MyRange:    def __init__(self, stop):        self.stop = stop    def __iter__(self):        return Next(self.stop)my_range = MyRange(5)  # &lt;__main__.MyRange object at 0x1045029d0&gt;# False 断言它不是一个迭代器,但是它可以被for遍历,所以__iter__返回值有__next__方法也可以print(isinstance(my_range, Iterator)) for item in my_range:    print(item)  # 也可以通过 for 遍历\n\n示例5: 基于MyRange使用while实现for \n\nfor 会自动调用 __iter__ , __next__ 方法,但是while不会,需要手动调用\n\n# 基于MyRange使用while实现fordef my_while():    start, stop = 0, 5    my_range = MyRange(stop)    numbers = my_range.__iter__()  # 手动调用__iter__方法    while start &lt; stop:        print(numbers.__next__())        start += 1my_while()\n\n\n\n1.7 generator生成器(高效):生成器是特殊的迭代器,迭代器是特殊的可迭代对象,那么生成器必定是可迭代对象\n\n使用yield关键字返回一个生成器对象\n\nfrom typing import Iterable, Iteratordef g_func2():    my_list = range(3)    for i in my_list:        yield i * ig = g_func2()print(isinstance(g, Iterable))  # Trueprint(g.__iter__())  # &lt;generator object g_func1 at 0x10271fc10&gt;print(next(g))print(next(g))print(next(g))print(hasattr(g, &quot;__iter__&quot;))  # Trueprint(hasattr(g, &quot;__next__&quot;))  # Trueprint(isinstance(g, Iterator))  # True\n\n\n\n1.8 for循环的本质\n\n调用iter()，将numbers转化为迭代器numbers_iterator\n调用next(numbers_iterator)，返回出numbers的第一个元素\n循环步骤2,迭代完numbers内所有数据,捕获异常\n\n\n# while + iteratornumbers = [1, 2, 3, 4]numbers_iterator = iter(numbers)while True:    try:        print(next(numbers_iterator))    except StopIteration:  # 捕捉异常终止循环        break# for循环for i in numbers:    print(i)\n\n\n\n1.9 itertools\n为高效循环而创建迭代器的函数\n\niterable = itertools.chain([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;])for i in iterable:    print(i)  # --&gt; A B C D E Ffrom_iterable = itertools.chain.from_iterable([&#x27;ABC&#x27;, &#x27;DEF&#x27;])for i in from_iterable:    print(i)r = itertools.combinations(&quot;ABCD&quot;, 2)for i in r:    print(i)  # --&gt; AB AC AD BC BD CD\n\n\n\n1.10 lambda、map、zip\nlamdba 处理简单业务逻辑\ny: any = lambda x: x + 1print(y(10))Students = [    &#123;&quot;name&quot;: &quot;a&quot;, &quot;age&quot;: 18&#125;,    &#123;&quot;name&quot;: &quot;c&quot;, &quot;age&quot;: 20&#125;,    &#123;&quot;name&quot;: &quot;b&quot;, &quot;age&quot;: 19&#125;,    &#123;&quot;name&quot;: &quot;ca&quot;, &quot;age&quot;: 19&#125;,    &#123;&quot;name&quot;: &quot;cb&quot;, &quot;age&quot;: 19&#125;]# 根据age排序,age一致时根据name排序print(sorted(Students, key=lambda student: (student[&quot;age&quot;], student[&quot;name&quot;])))\n\nmap(func, *iterables) –&gt; map object\n# map 可迭代对象元素合并 返回新的map对象,按最短的对象合并a = [1, 2, 3]b = [4, 5, ]# map(func, *iterables)# func --&gt; lambda a1, b1: (a1, b1)# *iterables --&gt; a, bnum1 = map(lambda a1, b1: (a1, b1), a, b)  # &lt;map object at 0x109efed60&gt;for i in num1:    print(i)  # (1, 4), (2, 5)\n\nreduce 求和\nfrom functools import reduceprint(reduce(lambda x, y: x + y, range(1, 101)))  # 5050\n\nfilter 过滤\nprint(list(filter(lambda x: x &gt; 5, range(10))))  # &lt;filter object at 0x106ad6c40&gt;\n\nzip\na = [1, 2, 3]b = [4, 5, 6, 7, 8]print(list(zip(a, b)))  # [(1, 4), (2, 5), (3, 6)]  # 元素个数与最短的列表一致\n\n1.11 namespace\n一般有三种命名空间:\n\n内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。\n全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。\n局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）\n\n\nPython的作用域一共有4种【规则顺序: L –&gt; E –&gt; G –&gt; gt; B】\n\nL（Local）:最内层，包含局部变量，比如一个函数&#x2F;方法内部。\n\nE（Enclosing）:包含了非局部(non-local)也非全局(non-global)的变量。\n比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。\n\nG（Global）:当前脚本的最外层，比如当前模块的全局变量。\n\nB（Built-in）: 包含了内建的变量&#x2F;关键字等。最后被搜索\n\n\n\n闭包\n\n1.在一个函数内部定义了另一个函数2.内部函数引用了外部函数的变量\n\ng_count = 0  # 全局作用域def outer():    o_count = 1  # 闭包函数外，函数中    print(f&quot;Enclosing: &#123;o_count&#125;&quot;)    def inner():        i_count = 2  # 局部作用域        print(f&quot;Local: &#123;i_count&#125;&quot;)        nonlocal o_count  # 外层作用域        o_count += 5        print(f&quot;Enclosing: &#123;o_count&#125;&quot;)    return inner  # 返回函数名称 可以被调用print(f&quot;Global: &#123;g_count&#125;&quot;)  # Global: 0func = outer()  # Enclosing: 1func()  # Local: 2 Enclosing: 6func()  # Local: 2 Enclosing: 11\n\n1.12 private_name# import 私有变量# 1. __name它不会被导入到导入模块的命名空间中# 2. _name会被导入到导入模块的命名空间中\n\nclass MyClass:    def __init__(self):        self.__name = &quot;Private Name&quot;  # 私有变量 __name        self._name = &quot;Conventionally Private Name&quot;  # 约定上的私有变量 _name    def get_private_name(self):        return self.__name    def get_conventionally_private_name(self):        return self._nameobj = MyClass()# 访问私有变量 __nameprint(obj.get_private_name())  # 输出: Private Name# print(obj.__name)  # 错误，在类外部，无法直接访问私有变量，会引发 AttributeError 错误print(obj._MyClass__name)  # 输出: Private Name，通过名称重整方式访问私有变量# 访问约定上的私有变量 _nameprint(obj.get_conventionally_private_name())  # 输出: Conventionally Private Nameprint(obj._name)  # 输出: Conventionally Private Name，可以直接访问约定上的私有变量\n\n\n\n2.装饰器(decorator)\n本质函数当作参数传递,利用闭包特性实现\n\n2.1 最原始的装饰器def add(*args):    return sum(args)# 把函数当做参数,传递给另外一个函数def new_add(func, *args):    return f&quot;对原函数进行装饰 遵循开放封闭原则: &#123;func(*args)&#125;&quot;print(new_add(add, 1, 2, 3))\n\n\n\n2.2 常见使用方式\n编写一个记录日志 和 统计函数执行耗时的装饰器\n\nimport timedef loger(func):    def wrapper(*args):        print(&quot;1 记录日志的代码...&quot;)        result = func(*args)        print(&quot;2 日志分析的代码...&quot;)        return result    return wrapper# 编写一个计算方法执行耗时的装饰器def timer(func):    def wrapper(*args, **kwargs):        print(&quot;3 计算耗时开始&quot;)        start_time = time.time()        result = func(*args)        end_time = time.time()        print(f&quot;&#123;func.__name__&#125;: 耗时: &#123;end_time - start_time&#125;&quot;)        print(&quot;4 计算耗时结束&quot;)        return result    return wrapper@loger@timerdef add(*args, **kwargs):    return sum(args)print(add(11, 1))  # 执行顺序: 1 -&gt; 3 -&gt; func.__name__耗时 -&gt; 4 -&gt; 2 -&gt; func执行结果\n\n\n\n2.3 装饰器带参数# 编写一个带参数的装饰器，用于验证用户登录def login_verify(is_login=False):  # 这里接收装饰器的参数    def inner(func):  # 接收被装饰的函数        def wrapper(*args, **kwargs):  # 这里接收被装饰函数的参数            if is_login:  # 装饰器的参数在这里使用，用于判断                print(&quot;被装饰函数执行前&quot;)                result = func(*args)                print(&quot;被装饰函数执行后&quot;)                return result            else:                return None        return wrapper  # 返回函数的包装器    return inner@login_verify(is_login=True)def add(*args, **kwargs):    return sum(args)print(add(11, 22))\n\n\n\n2.4 给类添加一个装饰器def class_name(cls):    cls.name = &quot;小明&quot;    return cls# 给类添加装饰器@class_nameclass A(object):    passprint(A.name)\n\n\n\n2.5 使用类编写装饰器class A:    def __init__(self, func):        self.func = func    def __call__(self, *args, **kwargs):        print(&quot;__call__ is running ...&quot;)        return self.func(*args)@A  # 本质 A(add)def add(*args):    return sum(args)print(add(1, 2))\n\n\n\n2.6 使用类编写装饰器带参数class S:    def __init__(self, func, name):        self.func = func        self.name = name    def __call__(self, *args, **kwargs):        print(&quot;类装饰器转入的参数&quot;, self.name)        print(&quot;1 装饰函数执行之前&quot;)        result = self.func(*args)        print(&quot;2 装饰函数执行之后&quot;)        return resultdef add(*args):    return sum(args)s = S(add, &quot;hello&quot;)print(s(1, 3))\n\n\n\n3.面向对象3.1 三大特性\n面向对象三大特性:继承 封装 多态\n\n# 面向对象三大特性:继承 封装 多态class Base(object):    def __init__(self):        self.leg = &quot;4&quot;    def func1(self):        print(f&quot;Base 有 &#123;self.leg&#125; 条腿...&quot;)class Cat(Base):    def func1(self):        print(f&quot;我是cat,有&#123;self.leg&#125;条腿...&quot;)        print(&quot;我会上树&quot;)class Dog(Base):    def func1(self):        print(f&quot;我是dog,有&#123;self.leg&#125;条腿...&quot;)        print(&quot;我跑得快&quot;)class Table(Base):    def func1(self):        print(f&quot;我是一个餐桌，也有&#123;self.leg&#125;条腿，但我不会跑...&quot;)def func(arg):    arg.func1()func(Base())func(Dog())func(Cat())func(Table())\n\n\n\n3.2 类方法和静态方法\nclassmethod 给类定义的方法staticmethod 目的只是封装在一起,内聚\n\nclass Person(object):    def __init__(self, name):        self.name = name    @classmethod    def name(cls, name):        return cls(name)    @staticmethod    def age(age: int):        return age    def __repr__(self):        return self.namea = Person(name=&quot;张三&quot;)print(a)b = Person.name(&quot;李四&quot;)print(b)print(a.age(18))  # 对象可以调用print(Person.age(20))  # 类也可以调用\n\n\n\n3.3 property装饰器\n1.将函数属性伪装成数据属性2.统一数据属性的查、改、删操作\n\nclass Person:    def __init__(self, name):        self.__name = name    @property    def name(self):        return self.__name    # 当name 遇到赋值操作, 即 = 时触发被property.setter装饰的函数的执行    @name.setter    def name(self, value):        self.__name = value    # 当name 遇到删除操作，即 del 时触发property.deleter装饰的函数的执行    @name.deleter    def name(self):        print(&#x27;deleter&#x27;)obj1 = Person(&#x27;abc&#x27;)print(obj1.name)obj1.name = &#x27;aaa&#x27;print(obj1.name)del obj1.name\n\n\n\n3.4 cached_property\n相比 property 增加缓存功能,针对不可变的高计算资源消耗的实例特征属性\n\nfrom functools import cached_property  # 内置 3.8版本才加入的cached_propertypip3 install cached-property  # 第三方包 支持asyncio\n\n\n\n3.5 属性查找顺序\n对象 —&gt;   父类   —&gt;    继承类,  依次类推,找不到则报错\n\n3.6 多继承\n多继承的优点:同时继承多个父类属性和方法，功能强大。\n多继承缺点:代码可读性变差。\n通过类的mro()方法查看多继承的查找顺序。\n__bases__ 可以查看类继承的所有父类\n\nprint(C.mro())# [&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]print(C.__bases__)  # (&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;)\n\n\n\n3.7 广度优先和深度优先# [&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.A1&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]# python3中全部默认继承object，所以都是新式类- object类提供了一些常用内置方法的实现,如用来在打印对象时返回字符串的内置方法__str__新式类:广度优先obj -&gt; &lt;class &#x27;__main__.C&#x27;&gt; -&gt; &lt;class &#x27;__main__.A1&#x27;&gt; ... -&gt; &lt;class &#x27;object&#x27;&gt;\n\n\n\n3.8 抽象基类\n1.抽象类本身不能实例化\n2.子类必须实现其定义接口\n\nimport abc# 指定metaclass属性将类设置为抽象类，抽象类本身不能实例化class Animal(metaclass=abc.ABCMeta):    @abc.abstractmethod  # 该装饰器限制子类必须定义有一个名为talk的方法    def talk(self):  # 抽象方法中无需实现具体的功能        passclass Cat(Animal):  # 但凡继承Animal的子类都必须遵循Animal规定的标准    def talk(self):  # 必须定义talk方法\t\t\t\t\t\t        passcat = Cat()  # 若子类中没有一个定义talk的方法则会抛出异常TypeError，无法实例化\n\n\n\n3.9 isinstance 和 issubclassprint(isinstance(a, int))  # 断言类型print(issubclass(People, Animal))   # 断言是否其子类\n\n\n\n3.10 动态获取对象信息(反射)hasattr(obj, &#x27;x&#x27;)\t                    # 判断对象是否有一个属性，返回布尔值getattr(object, name, default=None)\t  # 获取对象的name属性，name属性不存在的返回Nonesetattr(x, &#x27;y&#x27;, &#x27;v&#x27;)\t       # 更新x对象 y属性的值, 等价于 x.y = &#x27;v&#x27;，当y不存在的新增delattr(x, &#x27;y&#x27;)\t\t           # 删除x对象 y属性, 等价于 del x.y   属性y不存在则报错\n\n\n\n4.魔法函数4.1 __new__ 、__init__ 、__call __、__del__\n__new__       实例化对象（1.创建对象 2.分配内存）__init__    构造方法,实例化对象时自动调用(1.可以没有 2.如果有方法必须返回None,默认不写return语句)__call __  对象可以被调用时触发执行__del__      析构方法,当对象被回收时触发执行(程序结束、对象引用计数为零称为垃圾时)\n\nclass MyClass(object):    def __init__(self):        print(&quot;__init__ is running...&quot;)    def __new__(cls):        print(&quot;__new__ is running...&quot;)        return super().__new__(cls)  # 创建对象 分配内存    def __call__(self, *args, **kwargs):        print(&quot;__call__ is running...&quot;)    def __del__(self):        print(&quot;__del__ is running...&quot;)MyClass()  # 匿名对象程序并未使用到,执行完后就销毁了print(&quot;----------------------&quot;)a = MyClass()  # 这里会先执行__new__ 在执行 __init__assert hasattr(a, &quot;__del__&quot;)  # Trueprint(callable(a))  # True  可以被调用时结果为True,对象如果没有__call__ 属性则是Falseassert hasattr(lambda x, y: x + y, &quot;__call__&quot;)  # Trueprint(callable(lambda x, y: x + y))  # True\n\n\n\n4.2 __str__ 和 __repr__\n两个方法都只是为了自定义对象的打印信息  \n对象被打印时执行,一般默认先找str, str没有则使用repr\n\nclass A(object):    def __init__(self):        self.name = &quot;李四&quot;    def __str__(self):        print(&quot;__str__ is running ...&quot;)        return &quot;str&quot;    def __repr__(self):        print(&quot;__repr__ is running ...&quot;)        return &quot;&quot;print(A())  # 默认为 &lt;__main__.A object at 0x1043aa710&gt;\n\n\n\n4.3 compare系列class Student:    def __init__(self, age):        self.age = age    def __eq__(self, other):        print(&quot;__eq__ is running ... 可自定义比较逻辑&quot;)        if isinstance(other, Student):            return self.age == other.age  # 返回布尔值        return Falseprint(Student(18) == Student(18))print(Student(18) != 18)  # nq, 不相等的逻辑。如果没有实现，则默认是eq的结果取反。print(dir(Student(18)))  # __lt__、__gt__、__le__、__ge__ 分别表示小于、大于、小于等于和大于等于。\n\n\n\n4.4 attr系列class MyClass(object):    def __init__(self, name, age):        self.name = name        self.age = age    def __getattr__(self, item):        print(&quot;getattr 获取不存在的对象属性时触发&quot;)        # super().__delattr__(item)  # &#x27;MyClass&#x27; object has no attribute &#x27;id&#x27;        return self.__dict__.get(item)    def __setattr__(self, key, value):        print(&quot;setattr 设置修改对象属性时触发&quot;)        super().__setattr__(key, value)    def __delattr__(self, item):        print(&quot;delattr 删除对象属性时触发&quot;)        if item == &quot;name&quot;:  # 属性是name时抛出异常，或者不进行删除操作            # raise AttributeError(&quot;name 属性不让删除...&quot;)            pass        else:            super().__delattr__(item)    def __getattribute__(self, name):        # 访问任何属性（包括存在的和不存在的属性）时都会调用 __getattribute__ 方法        print(&quot;__getattribute__ called&quot;)        return super().__getattribute__(name)a = MyClass(&quot;李四&quot;, 18)  # 每一次给属性赋值 都会执行setattr方法print(a.id)del a.age  # 触发delattr方法print(f&quot;查看对象属性:&#123;a.__dict__&#125;&quot;)\n\n\n\n4.5 item系列# 一个普通对象通过[] 操作取值时会触发 __getitem__class Person(object):    def __setitem__(self, key, value):        print(&quot;setitem []设置值时触发&quot;)        setattr(self, key, value)    def __getitem__(self, item):        print(&quot;getitem []取值时触发&quot;)        return getattr(self, item)    def __delitem__(self, key):        print(&quot;delitem del p[key]时触发&quot;, key)p = Person()p[&#x27;id&#x27;] = 1  # 触发setitem方法print(p[&#x27;id&#x27;])  # 触发getitem方法del p[&#x27;id&#x27;]  # 触发delitem方法\n\n\n\n4.6 __enter__ 和 __exit__\n上下文管理器: 支持”上下文管理协议”的对象,包含 enter() 和 exit() 方法with 可以操作一个 支持上下文管理协议的对象\n\nclass MyOpen:    def __init__(self, file_name: str, mode=&quot;r&quot;):        self.file = open(file_name, mode)    def __enter__(self):        print(&quot;进入with语句块时触发&quot;)        return self.file  # 返回值赋值给 as后面的接收值    def __exit__(self, exc_type, exc_val, exc_tb):        print(&quot;退出with语句块时触发,不论with语句块是否有异常报错，__exit__都会被执行&quot;)        self.file.close()with MyOpen(&quot;test&quot;, &quot;w&quot;) as f:    f.write(&quot;hello world&quot;)\n\n\n\n4.7 __slots__\n该类实例只能创建__slots__中声明的属性，否则报错, 具体作用就是节省内存\n\nfrom memory_profiler import profileclass Test(object):    __slots__ = [&#x27;a&#x27;, &#x27;name&#x27;]    def __init__(self, name):        self.name = nameTest.c = 3  # 类属性仍然可以自由添加t = Test(&quot;xx&quot;)t.a = 1print(t.c)  # 绕过限制就是给类添加属性# t.b = 2  # AttributeError: &#x27;Test&#x27; object has no attribute &#x27;b&#x27;class TestA(object):    __slots__ = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]    def __init__(self, a, b, c):        self.a = a        self.b = b        self.c = cclass TestB(object):    def __init__(self, a, b, c):        self.a = a        self.b = b        self.c = c@profiledef func_02():    temp = [TestA(i, i + 1, i + 2) for i in range(10000)]    del temp    temp = [TestB(i, i + 1, i + 2) for i in range(10000)]    del tempfunc_02()\n\n\n\n4.8 __add__、 __dict__、 __bases__、 __all__\n__add__:  手动实现相加操作__dict__: 获取对象的属性__bases__: 获取类继承的元素__all__: 当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 __all__ 列表中指定的成员\n\nclass MyClass(object):    def __init__(self, value):        self.value = value    def __add__(self, other):        # other这里传入的是第二个对象 obj2  obj2.value ==》 __init__ 初始化中传入的value        return self.value + other.valuea = MyClass(10)print(a + MyClass(20))print(MyClass.__dict__)# __bases__  这是一个元祖，里面的元素是继承的类class A(object):    passprint(A.__bases__)# 当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 `__all__` 列表中指定的成员__all__ = [&quot;MyClass&quot;]\n\n","tags":["python"]},{"title":"python-路径导入问题","url":"/blog/2024/05/05/python/base/py-02%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%85%A5/","content":"python文件运行时路径导入的问题\n 错误提示：ModuleNotFoundError: No module named ‘xxxx’\n\n解决这个问题首先要明白Python运行时，Python解释器会按照一定的搜索路径来查找模块和包。\n可以通过sys.path查看具体信息\nimport sysprint(sys.path)\n\n[&#x27;/Users/jw/Documents/github/abcd/b&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python312.zip&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/lib-dynload&#x27;, &#x27;/opt/homebrew/lib/python3.12/site-packages&#x27;, &#x27;/Users/jw/Documents/github/abcd&#x27;]\n\n\n当前工作目录：即列表下标为0的元素，解释器会首先在当前目录中搜索模块，当前工作目录是指在运行Python脚本时所在的目录\nPYTHONPATH环境变量：PYTHONPATH环境变量可以用来指定额外的模块搜索路径。它是一个包含多个目录路径的列表，Python解释器会按照列表中的顺序进行搜索。\n\n# 可以通过以下命令在终端查看echo $PYTHONPATH \n\n这种方式比较隐蔽，不常用，需要操作者知情才会去查看此环境变量\n\n系统默认路径：Python解释器会在一组默认的系统路径中搜索模块。这些路径包括Python标准库的位置以及安装的第三方库的位置。【参考上述path路径中展示，除最后一个元素和第一个元素外】\n\n解决方案abcd/├── a/│ ├── init.py│ └── m.py           # m.py中有一个变量 aa = 11└── b/├── init.py└── mb.py          #  在此路径下运行 mb.py 文件 并打印出变量 aa\n\n# mb.pyfrom a.m import aaprint(aa)File &quot;/Users/jw/Documents/github/abcd/b/mb.py&quot;, line 29, in &lt;module&gt;    from a.m import aaModuleNotFoundError: No module named &#x27;a&#x27;\n\n将模块a添加至path路径中\nimport sysfrom pathlib import Pathroot_path = Path(__file__).resolve().parent.parentsys.path.append(str(root_path))  # 将root_path添加到PATH，并会在此模块下搜索print(sys.path)  # 此处会输出path的所有内容from a.m import aaprint(aa)   # 成功输出变量信息\n\n\n\n类似场景abcd/├── a/│ ├── init.py│ └── m.py           # m.py中有一个变量 aa = 11└── b/├── init.py└── mb.py            #  在此路径下运行 mb.py 文件 并打印出变量 aa└ main.py             # 程序主入口\n\n# mian.pyfrom a.m import aaprint(aa)\n\nmain.py 无需添加至PATH即可成功输出aa变量的原因现在知道了吗？\n根据上述结论推导：\nmain.py文件在运行时，会在当前工作目录下搜索包，即能找到a模块也可以找到b模块，无需添加\n\n","tags":["python"]},{"title":"python-重复逻辑优化篇","url":"/blog/2023/08/21/python/project/py-%E9%87%8D%E5%A4%8D%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96%E7%AF%87/","content":"1.解决api请求变更,URL和参数更新维护等问题？引入客户端代码生成工具,根据接口文档自动生成代码,从而减少由于接口变更的维护成本\n官网地址: https://swagger.io/tools/swagger-codegen/\n\n下载swagger codegen \n生成对应语言客户端代码  [-i 指定api接口路径,-lang 指定语言,-o 指定生成代码文件路径]\n\n阅读生成项目的readme,提供了使用教程​\t\t\nswagger-codegen generate -i http://ip:port/static/openapi.yml --lang python -o ./me_api_clientswagger-codegen generate -i http://ip:port/static/openapi.yml --lang go -o ./me_api_client\n\n\n\n\n2. 项目结构分析\n客户端需要连接到指定节点，能提供多节点测试\n客户端需要提供命令生成器 和 执行器\n操作每个模块都需要自定义其模块方法，成本较高，并且大致逻辑一致\n\nNode模块：\n\n初始化node实例提供连接节点功能\nnode实例默认提供对应 交易的一些常用命令设置\nnode都绑定有执行器(executor) 和 命令生成器（generate_xxx）\n\nimport inspectfrom typing import Callablefrom loguru import loggerfrom config.config import app_chainfrom ssh import Client, Resultclass Node:    ssh_client = Client(ip=app_chain.Host.ip, port=app_chain.Host.port,                        username=app_chain.Host.username, password=app_chain.Host.password)    config = app_chain    def __init__(self, node: str):        super().__init__()        if &quot;--node&quot; not in node:            node = f&quot;--node=&#123;node&#125;&quot;        self.config.Flags.node = node        self.superadmin = self.__get_superadmin_addr()        self.__init_instance_config()    def update_config(self, attr: str, key: str, value: str):        &quot;&quot;&quot;        If key exists in the attr object, replace the value. If no, add the value        :param attr: &#x27;ApplicationChain&#x27; object must have attr        :param key:        :param value:        :return:        &quot;&quot;&quot;        sub_cfg_gen = getattr(self.config, attr)        found_key = False        for i in sub_cfg_gen:            if i[0] == key:                setattr(sub_cfg_gen, key, value)                found_key = True                break        if not found_key:            setattr(sub_cfg_gen, key, value)    def __init_instance_config(self):        self.update_config(&quot;Flags&quot;, &quot;fees&quot;, &quot;--fees=100umec&quot;)        self.update_config(&quot;Flags&quot;, &quot;gas&quot;, &quot;--gas=200000&quot;)    @property    def base_cmd(self):        return f&quot;&#123;self.config.Host.chain_work_path&#125; &quot;    def __get_superadmin_addr(self):        get_superadmin_cmd = f&quot;&#123;self.base_cmd&#125; keys show superadmin -a &#123;self.config.Flags.keyring_backend&#125;&quot;        return self.ssh_client.exec_cmd(get_superadmin_cmd)    def generate_query_cmd(self, cmd: str):        query_cmd = self.base_cmd + f&quot;&#123;self.config.Flags.node&#125; &#123;self.config.GlobalFlags.chain_id&#125; &quot;        return query_cmd + cmd    def generate_tx_cmd(self, cmd: str):        tx_cmd = self.base_cmd + (f&quot;&#123;self.config.Flags.fees&#125; &#123;self.config.Flags.gas&#125; &quot;                                  f&quot;&#123;self.config.Flags.yes&#125; &#123;self.config.Flags.keyring_backend&#125; &quot;                                  f&quot;&#123;self.config.Flags.node&#125; &#123;self.config.GlobalFlags.chain_id&#125; &quot;)        return tx_cmd + cmd    def generate_keys_cmd(self, cmd: str):        keys_cmd = self.base_cmd + f&quot;&#123;self.config.Flags.keyring_backend&#125; &quot;        return keys_cmd + cmd    def executor(self, cmd):        logger.info(f&quot;&#123;inspect.stack()[0][3]&#125;: &#123;cmd&#125;&quot;)        if &quot;keys add&quot; in cmd:            _ = self.ssh_client.channel.send(cmd + &quot;\\n&quot;)            resp_info = self.ssh_client.Interactive.read_channel_data(self.ssh_client.channel)            if &quot;existing&quot; in resp_info:                resp_info = self.ssh_client.Interactive.input_yes_or_no(self.ssh_client.channel)            assert &quot;**Important**&quot; in resp_info            return resp_info        resp_info = self.ssh_client.exec_cmd(cmd, strip=False)        if resp_info.failed:            logger.info(f&quot;resp_info.stderr: &#123;resp_info.stderr&#125;&quot;)            return resp_info.stderr        return Result.yaml_to_dict(resp_info.stdout)\n\n\n\nMeta元类:\n为每个类动态生成方法,解决其定义冗余\nclass Meta(type):    def __init__(cls, name, bases, attrs):        cls.module = name.lower()  # 创建类module = 其类名称小写        super().__init__(name, bases, attrs)        sub_module = attrs.get(&#x27;sub_module&#x27;, [])        parent_module = attrs.get(&#x27;parent_module&#x27;, &#x27;&#x27;)        if isinstance(sub_module, list):            for module in sub_module:              \t# 添加类方法，名称为其子模块                method = cls.generate_method(parent_module, module)                setattr(cls, module, classmethod(method))        elif isinstance(sub_module, dict):            for k, module in sub_module.items():                method = cls.generate_method(parent_module, module)                setattr(cls, k, classmethod(method))        else:            raise f&quot;sub_module type error: &#123;type(sub_module)&#125;, expect list or dict&quot;    @staticmethod    def generate_method(parent_module, sub_module) -&gt; Callable[..., str]:       # 利用闭包特性，生成的类方法只接受 *args,**kwargs 参数        def method(cls, *args, **kwargs):            return cls.build_command(parent_module, sub_module, *args, **kwargs)        return method    def build_command(cls, parent_module, sub_module, *args, **kwargs):        args_str = &quot; &quot;.join(map(str, args))        kwargs_str = &quot; &quot;.join([f&quot;--&#123;key&#125;=&#123;value&#125;&quot; for key, value in kwargs.items() if value != &quot;&quot;])        return f&quot;&#123;parent_module&#125; &#123;cls.module&#125; &#123;sub_module&#125; &#123;args_str&#125; &#123;kwargs_str&#125; &quot;    def __getattr__(cls, attr):        raise AttributeError(f&quot;&#x27;&#123;cls.__name__&#125;&#x27; class has no attribute &#x27;&#123;attr&#125;&#x27;&quot;)    def help(cls):        for attr_name in cls.sub_module:            attr = getattr(cls, attr_name)            if not callable(attr):                raise TypeError(f&quot;attribute &#x27;&#123;attr_name&#125;&#x27; is not callable&quot;)        print(f&quot;Available methods: &#123;list(cls.sub_module)&#125;&quot;)        print(f&quot;Example usage: &#123;cls.__name__&#125;.&#123;list(cls.sub_module)[0]&#125;(&#x27;argument&#x27;)&quot;)\n\n\n\n","tags":["python","tools"]}]