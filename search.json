[{"title":"00-开篇","url":"/blog/2023/03/03/software-test-collection/00-%E5%BC%80%E7%AF%87/","content":"1.初衷在职场中迷茫是常见的经历，为了激励自己继续前行，总结过往经历并进行优化是一个不错的做法。\n关于软件测试的经历，带着问题去实践寻找答案：\n1.1 目标与动机：最初选择这个行业的动机是什么？目标是什么？有两句话一直警示着我，在此分享给大家\n\n如果建筑工人盖房子的方式跟程序员写程序一样，那第一只飞来的啄木鸟就将毁掉人类文明\n软件测试的价值在于将原本暴露在用户面前的缺陷，提前在内部发现并解决\n\n然后基于很多项目或公司实际情况，不能说测试无用但收益甚微【小公司尤其明显】，存在的问题可能是多种多样的，一方面是企业对质量的重视程度，一方面是测试人员本身技能不足都有关系。\n1.2 技能与知识：掌握技能主要是为了解决实际问题\n比如常见的接口测试，需要掌握一些接口调试工具：postman、curl等\n手工测试进度很慢就需要引入自动化，比如掌握一门编程语言和发请求的库，针对业务场景结合完成测试\n对于性能测试则需要掌握压测工具，特定场景下工具无法解决问题，就多掌握一门高性能编程语言，本质还是在处理发起请求的问题\n在分布式系统中重点关注数据一致性的解决方案，从理解共识算法开始更容易发现应用层的错误，以及发现错误后如何推理并找出问题所在\n\n技能终究是工具，掌握多样化的工具是为了在解决问题时提供解决方案，去做别人不可替代的事才有价值。\n2.软测基本三阶段2.1 入门、初级\n入门不难，周期短，一般计算机专业的学生对于软件开发有一定经验，通过三个月的自学也能达到岗位需求\n技术栈比较浅，特别是在当前市场环境下，不推荐入坑\n\n2.2 中、高级\n目前市场上需求，至少需要熟悉自动化测试、性能测试，掌握一门编程语言，有测试平台的开发经验更佳\n\n普遍岗位也没有太深入，大部分还是api调用工程师，不过能有专职的自动化岗位还是不错的，主要有时间能沉下心去学习，在持续的学习中接触到更多的知识才会发现自己掌握的只是冰山一角\n\n很多高级测试也只是编写维护自动化而已，自动化能解决一些问题，也会带来问题\n\n什么时候要自动化？如何自动化？自动化程度如何，全部还是部分\n维护成本也不能忽视，为了测试程序招了比开发还水的团队维护着大量的测试代码，这本就是一个伪命题\n\n\n测试开发岗、对于大厂而言还有精力和能力去打磨高效的测试平台，其要求的能力并不低普遍对标开发水平。除大厂内部自研的系统外，目前并没有明星产品的推出能一统天下，各系统不同关注点都需要编码去实现。\n推荐两个平台关注下：\n\nRunnerGo go 微服务开发技术栈，一款全栈式测试平台\nMeterSphere java 技术栈，一站式开源持续测试平台\n\n\n\n2.3 资深、专家、测试管理\n某特定场景下能提供完整解决方案，拿人钱财替人消灾\n代码审计，软件架构，优化方案，解决核心问题的能力提高了自然会成为所谓的专家\n有了架构师，所谓测试架构师存在的意义又是什么呢？\n\n3.改变在步入web3行业后，工作中发现在此领域中大家对于软件的质量尤其关注，特别是智能合约\n测试经验在智能合约开发中是尤为重要的一部分，web3领域对于安全的缺口也很大\n4.总结4.1 要做软测知识汇总，以实际工作为主，做实践项目输出主要帮助的人群是长期功能测试&#x2F;自动化无法落地的同学提升竞争力\n4.2 要学习web3并形成个人的知识体系，并培养自己在web3行业的竞争力除了个人需要较强的自制力外，还需要有良好的团队组队，以交流促进学习并相互监督\n4.3 选对路比盲目努力重要首先要相信选择的路是有希望的，才能坚持学下去，目标先掌握rust，上山的路其实并不拥挤\n\n共勉。\n","categories":["software-test-collection"],"tags":["software-test"]},{"title":"02-装饰器","url":"/blog/2023/03/05/software-test-collection/01-10_python%E5%9F%BA%E7%A1%80/02-%E8%A3%85%E9%A5%B0%E5%99%A8/","content":"2.装饰器(decorator)\n本质函数当作参数传递,利用闭包特性实现\n\n2.1 最原始的装饰器def add(*args):    return sum(args)# 把函数当做参数,传递给另外一个函数def new_add(func, *args):    return f&quot;对原函数进行装饰 遵循开放封闭原则: &#123;func(*args)&#125;&quot;print(new_add(add, 1, 2, 3))\n\n\n\n2.2 常见使用方式\n编写一个记录日志 和 统计函数执行耗时的装饰器\n\nimport timedef loger(func):    def wrapper(*args):        print(&quot;1 记录日志的代码...&quot;)        result = func(*args)        print(&quot;2 日志分析的代码...&quot;)        return result    return wrapper# 编写一个计算方法执行耗时的装饰器def timer(func):    def wrapper(*args, **kwargs):        print(&quot;3 计算耗时开始&quot;)        start_time = time.time()        result = func(*args)        end_time = time.time()        print(f&quot;&#123;func.__name__&#125;: 耗时: &#123;end_time - start_time&#125;&quot;)        print(&quot;4 计算耗时结束&quot;)        return result    return wrapper@loger@timerdef add(*args, **kwargs):    return sum(args)print(add(11, 1))  # 执行顺序: 1 -&gt; 3 -&gt; func.__name__耗时 -&gt; 4 -&gt; 2 -&gt; func执行结果\n\n\n\n2.3 装饰器带参数# 编写一个带参数的装饰器，用于验证用户登录def login_verify(is_login=False):  # 这里接收装饰器的参数    def inner(func):  # 接收被装饰的函数        def wrapper(*args, **kwargs):  # 这里接收被装饰函数的参数            if is_login:  # 装饰器的参数在这里使用，用于判断                print(&quot;被装饰函数执行前&quot;)                result = func(*args)                print(&quot;被装饰函数执行后&quot;)                return result            else:                return None        return wrapper  # 返回函数的包装器    return inner@login_verify(is_login=True)def add(*args, **kwargs):    return sum(args)print(add(11, 22))\n\n\n\n2.4 给类添加一个装饰器def class_name(cls):    cls.name = &quot;小明&quot;    return cls# 给类添加装饰器@class_nameclass A(object):    passprint(A.name)\n\n\n\n2.5 使用类编写装饰器class A:    def __init__(self, func):        self.func = func    def __call__(self, *args, **kwargs):        print(&quot;__call__ is running ...&quot;)        return self.func(*args)@A  # 本质 A(add)def add(*args):    return sum(args)print(add(1, 2))\n\n\n\n2.6 使用类编写装饰器带参数class S:    def __init__(self, func, name):        self.func = func        self.name = name    def __call__(self, *args, **kwargs):        print(&quot;类装饰器转入的参数&quot;, self.name)        print(&quot;1 装饰函数执行之前&quot;)        result = self.func(*args)        print(&quot;2 装饰函数执行之后&quot;)        return resultdef add(*args):    return sum(args)s = S(add, &quot;hello&quot;)print(s(1, 3))\n\n","categories":["software-test-collection"],"tags":["software-test","python"]},{"title":"03-对象","url":"/blog/2023/03/06/software-test-collection/01-10_python%E5%9F%BA%E7%A1%80/03-%E5%AF%B9%E8%B1%A1/","content":"3.面向对象3.1 三大特性\n面向对象三大特性:继承 封装 多态\n\n# 面向对象三大特性:继承 封装 多态class Base(object):    def __init__(self):        self.leg = &quot;4&quot;    def func1(self):        print(f&quot;Base 有 &#123;self.leg&#125; 条腿...&quot;)class Cat(Base):    def func1(self):        print(f&quot;我是cat,有&#123;self.leg&#125;条腿...&quot;)        print(&quot;我会上树&quot;)class Dog(Base):    def func1(self):        print(f&quot;我是dog,有&#123;self.leg&#125;条腿...&quot;)        print(&quot;我跑得快&quot;)class Table(Base):    def func1(self):        print(f&quot;我是一个餐桌，也有&#123;self.leg&#125;条腿，但我不会跑...&quot;)def func(arg):    arg.func1()func(Base())func(Dog())func(Cat())func(Table())\n\n\n\n3.2 类方法和静态方法\nclassmethod 给类定义的方法staticmethod 目的只是封装在一起,内聚\n\nclass Person(object):    def __init__(self, name):        self.name = name    @classmethod    def name(cls, name):        return cls(name)    @staticmethod    def age(age: int):        return age    def __repr__(self):        return self.namea = Person(name=&quot;张三&quot;)print(a)b = Person.name(&quot;李四&quot;)print(b)print(a.age(18))  # 对象可以调用print(Person.age(20))  # 类也可以调用\n\n\n\n3.3 property装饰器\n1.将函数属性伪装成数据属性2.统一数据属性的查、改、删操作\n\nclass Person:    def __init__(self, name):        self.__name = name    @property    def name(self):        return self.__name    # 当name 遇到赋值操作, 即 = 时触发被property.setter装饰的函数的执行    @name.setter    def name(self, value):        self.__name = value    # 当name 遇到删除操作，即 del 时触发property.deleter装饰的函数的执行    @name.deleter    def name(self):        print(&#x27;deleter&#x27;)obj1 = Person(&#x27;abc&#x27;)print(obj1.name)obj1.name = &#x27;aaa&#x27;print(obj1.name)del obj1.name\n\n\n\n3.4 cached_property\n相比 property 增加缓存功能,针对不可变的高计算资源消耗的实例特征属性\n\nfrom functools import cached_property  # 内置 3.8版本才加入的cached_propertypip3 install cached-property  # 第三方包 支持asyncio\n\n\n\n3.5 属性查找顺序\n对象 —&gt;   父类   —&gt;    继承类,  依次类推,找不到则报错\n\n3.6 多继承\n多继承的优点:同时继承多个父类属性和方法，功能强大。\n多继承缺点:代码可读性变差。\n通过类的mro()方法查看多继承的查找顺序。\n__bases__ 可以查看类继承的所有父类\n\nprint(C.mro())# [&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]print(C.__bases__)  # (&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;)\n\n\n\n3.7 广度优先和深度优先# [&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.A1&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]# python3中全部默认继承object，所以都是新式类- object类提供了一些常用内置方法的实现,如用来在打印对象时返回字符串的内置方法__str__新式类:广度优先obj -&gt; &lt;class &#x27;__main__.C&#x27;&gt; -&gt; &lt;class &#x27;__main__.A1&#x27;&gt; ... -&gt; &lt;class &#x27;object&#x27;&gt;\n\n\n\n3.8 抽象基类\n1.抽象类本身不能实例化\n2.子类必须实现其定义接口\n\nimport abc# 指定metaclass属性将类设置为抽象类，抽象类本身不能实例化class Animal(metaclass=abc.ABCMeta):    @abc.abstractmethod  # 该装饰器限制子类必须定义有一个名为talk的方法    def talk(self):  # 抽象方法中无需实现具体的功能        passclass Cat(Animal):  # 但凡继承Animal的子类都必须遵循Animal规定的标准    def talk(self):  # 必须定义talk方法\t\t\t\t\t\t        passcat = Cat()  # 若子类中没有一个定义talk的方法则会抛出异常TypeError，无法实例化\n\n\n\n3.9 isinstance 和 issubclassprint(isinstance(a, int))  # 断言类型print(issubclass(People, Animal))   # 断言是否其子类\n\n\n\n3.10 动态获取对象信息(反射)hasattr(obj, &#x27;x&#x27;)\t                    # 判断对象是否有一个属性，返回布尔值getattr(object, name, default=None)\t  # 获取对象的name属性，name属性不存在的返回Nonesetattr(x, &#x27;y&#x27;, &#x27;v&#x27;)\t       # 更新x对象 y属性的值, 等价于 x.y = &#x27;v&#x27;，当y不存在的新增delattr(x, &#x27;y&#x27;)\t\t           # 删除x对象 y属性, 等价于 del x.y   属性y不存在则报错\n","categories":["software-test-collection"],"tags":["software-test","python"]},{"title":"04-魔法方法","url":"/blog/2023/03/07/software-test-collection/01-10_python%E5%9F%BA%E7%A1%80/04-%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/","content":"4.魔法函数4.1 __new__ 、__init__ 、__call __、__del__\n__new__       实例化对象（1.创建对象 2.分配内存）__init__    构造方法,实例化对象时自动调用(1.可以没有 2.如果有方法必须返回None,默认不写return语句)__call __  对象可以被调用时触发执行__del__      析构方法,当对象被回收时触发执行(程序结束、对象引用计数为零称为垃圾时)\n\nclass MyClass(object):    def __init__(self):        print(&quot;__init__ is running...&quot;)    def __new__(cls):        print(&quot;__new__ is running...&quot;)        return super().__new__(cls)  # 创建对象 分配内存    def __call__(self, *args, **kwargs):        print(&quot;__call__ is running...&quot;)    def __del__(self):        print(&quot;__del__ is running...&quot;)MyClass()  # 匿名对象程序并未使用到,执行完后就销毁了print(&quot;----------------------&quot;)a = MyClass()  # 这里会先执行__new__ 在执行 __init__assert hasattr(a, &quot;__del__&quot;)  # Trueprint(callable(a))  # True  可以被调用时结果为True,对象如果没有__call__ 属性则是Falseassert hasattr(lambda x, y: x + y, &quot;__call__&quot;)  # Trueprint(callable(lambda x, y: x + y))  # True\n\n\n\n4.2 __str__ 和 __repr__\n两个方法都只是为了自定义对象的打印信息  \n对象被打印时执行,一般默认先找str, str没有则使用repr\n\nclass A(object):    def __init__(self):        self.name = &quot;李四&quot;    def __str__(self):        print(&quot;__str__ is running ...&quot;)        return &quot;str&quot;    def __repr__(self):        print(&quot;__repr__ is running ...&quot;)        return &quot;&quot;print(A())  # 默认为 &lt;__main__.A object at 0x1043aa710&gt;\n\n\n\n4.3 compare系列class Student:    def __init__(self, age):        self.age = age    def __eq__(self, other):        print(&quot;__eq__ is running ... 可自定义比较逻辑&quot;)        if isinstance(other, Student):            return self.age == other.age  # 返回布尔值        return Falseprint(Student(18) == Student(18))print(Student(18) != 18)  # nq, 不相等的逻辑。如果没有实现，则默认是eq的结果取反。print(dir(Student(18)))  # __lt__、__gt__、__le__、__ge__ 分别表示小于、大于、小于等于和大于等于。\n\n\n\n4.4 attr系列class MyClass(object):    def __init__(self, name, age):        self.name = name        self.age = age    def __getattr__(self, item):        print(&quot;getattr 获取不存在的对象属性时触发&quot;)        # super().__delattr__(item)  # &#x27;MyClass&#x27; object has no attribute &#x27;id&#x27;        return self.__dict__.get(item)    def __setattr__(self, key, value):        print(&quot;setattr 设置修改对象属性时触发&quot;)        super().__setattr__(key, value)    def __delattr__(self, item):        print(&quot;delattr 删除对象属性时触发&quot;)        if item == &quot;name&quot;:  # 属性是name时抛出异常，或者不进行删除操作            # raise AttributeError(&quot;name 属性不让删除...&quot;)            pass        else:            super().__delattr__(item)    def __getattribute__(self, name):        # 访问任何属性（包括存在的和不存在的属性）时都会调用 __getattribute__ 方法        print(&quot;__getattribute__ called&quot;)        return super().__getattribute__(name)a = MyClass(&quot;李四&quot;, 18)  # 每一次给属性赋值 都会执行setattr方法print(a.id)del a.age  # 触发delattr方法print(f&quot;查看对象属性:&#123;a.__dict__&#125;&quot;)\n\n\n\n4.5 item系列# 一个普通对象通过[] 操作取值时会触发 __getitem__class Person(object):    def __setitem__(self, key, value):        print(&quot;setitem []设置值时触发&quot;)        setattr(self, key, value)    def __getitem__(self, item):        print(&quot;getitem []取值时触发&quot;)        return getattr(self, item)    def __delitem__(self, key):        print(&quot;delitem del p[key]时触发&quot;, key)p = Person()p[&#x27;id&#x27;] = 1  # 触发setitem方法print(p[&#x27;id&#x27;])  # 触发getitem方法del p[&#x27;id&#x27;]  # 触发delitem方法\n\n\n\n4.6 __enter__ 和 __exit__\n上下文管理器: 支持”上下文管理协议”的对象,包含 enter() 和 exit() 方法with 可以操作一个 支持上下文管理协议的对象\n\nclass MyOpen:    def __init__(self, file_name: str, mode=&quot;r&quot;):        self.file = open(file_name, mode)    def __enter__(self):        print(&quot;进入with语句块时触发&quot;)        return self.file  # 返回值赋值给 as后面的接收值    def __exit__(self, exc_type, exc_val, exc_tb):        print(&quot;退出with语句块时触发,不论with语句块是否有异常报错，__exit__都会被执行&quot;)        self.file.close()with MyOpen(&quot;test&quot;, &quot;w&quot;) as f:    f.write(&quot;hello world&quot;)\n\n\n\n4.7 __slots__\n该类实例只能创建__slots__中声明的属性，否则报错, 具体作用就是节省内存\n\nfrom memory_profiler import profileclass Test(object):    __slots__ = [&#x27;a&#x27;, &#x27;name&#x27;]    def __init__(self, name):        self.name = nameTest.c = 3  # 类属性仍然可以自由添加t = Test(&quot;xx&quot;)t.a = 1print(t.c)  # 绕过限制就是给类添加属性# t.b = 2  # AttributeError: &#x27;Test&#x27; object has no attribute &#x27;b&#x27;class TestA(object):    __slots__ = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]    def __init__(self, a, b, c):        self.a = a        self.b = b        self.c = cclass TestB(object):    def __init__(self, a, b, c):        self.a = a        self.b = b        self.c = c@profiledef func_02():    temp = [TestA(i, i + 1, i + 2) for i in range(10000)]    del temp    temp = [TestB(i, i + 1, i + 2) for i in range(10000)]    del tempfunc_02()\n\n\n\n4.8 __add__、 __dict__、 __bases__、 __all__\n__add__:  手动实现相加操作__dict__: 获取对象的属性__bases__: 获取类继承的元素__all__: 当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 __all__ 列表中指定的成员\n\nclass MyClass(object):    def __init__(self, value):        self.value = value    def __add__(self, other):        # other这里传入的是第二个对象 obj2  obj2.value ==》 __init__ 初始化中传入的value        return self.value + other.valuea = MyClass(10)print(a + MyClass(20))print(MyClass.__dict__)# __bases__  这是一个元祖，里面的元素是继承的类class A(object):    passprint(A.__bases__)# 当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 `__all__` 列表中指定的成员__all__ = [&quot;MyClass&quot;]\n\n","categories":["software-test-collection"],"tags":["software-test","python"]},{"title":"00-区块链基础","url":"/blog/2024/05/08/blockchain/0-base/00-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/","content":"\n文章将使用问答的形式进行区块链基础知识的讲解，同时满足学习和面试需求\n\n1.什么是区块链？区块链是一种分布式的、去中心化的数字账本技术，用于记录和验证交易与数据。区块链的核心概念是将交易和数据记录在一个被称为”区块”的数据结构中，并通过加密和共识算法保证数据的安全性和一致性。每个区块包含了一批交易的信息，以及与之前区块的链接，形成了一个链式结构。\n2.区块链有什么特点？在区块链中，参与者通过网络共享和维护这个账本的副本，而不是依赖于中央机构来验证交易。这种去中心化的特性使得区块链具有以下特点：\n\n透明性：区块链中的交易和数据是公开可见的，任何人都可以查看账本的副本。这提供了一种透明的方式来验证交易和监督系统的运作。\n安全性：区块链使用密码学技术对数据进行加密和验证，从而确保数据的安全性和完整性。由于数据存储在多个节点上，篡改数据变得非常困难。\n去中心化：区块链没有中央机构或控制权，参与者通过共识算法来达成对账本的一致认可。这使得区块链具有更高的可信度和抗攻击能力。\n不可篡改性：一旦数据被记录在区块链上，由于每个区块都包含了前一个区块的哈希值，任何对数据的篡改都将被其他节点检测到。\n\n3.区块链的运作方式3.1 哈希函数理想的加密哈希函数具备5个主要属性：\n\n确定性：相同的消息总是产生相同的哈希值。\n快速：快速计算任何给定消息的哈希值。\n抵抗性：除非尝试所有可能的消息，否则从其哈希值生成消息是不可行的。\n不相关：对消息的微小更改会极大地改变哈希值，以至于新值与旧值没有关系。\n抗碰撞：不可能找到具有相同哈希值的两个不同消息。\n\n3.2 区块、链\n有效区块是一组有序的交易。\n每个块都包含前一个块的哈希值。 \n区块的哈希值具有易证明难伪造。\n\n区块链接方式如下图示例：\n\n\n4.交易的运作方式4.1 加密钱包\n钱包并不存储加密资产，它们只存储私钥\n\n先理解三个重要概念：\n\n私钥、公钥、地址：公私钥通过非对称加密生成，公钥用于分发，私钥用于个人保留，地址通过公钥推导\n加密与解密：消息传递通过公钥加密、私钥解密\n签名与验证：交易信息通过私钥签名、公钥验证签名\n\n\n\n4.2 以BTC为例，讲解一笔交易流程\n用户B转账 1 bitcoin 至用户A\n\n\n\n\n用户B使用自己的私钥签名完成交易信息【确认用户B有足够的代币】\n将交易信息发送至节点，节点使用公钥验证交易信息，并存储在内存池中。\n节点将交易分组在区块中，并广播到其他节点。\n共识成功并出块后，用户A才能获取到1 bitcoin。\n\n5.共识5.1 工作量证明（PoW）\n去中心化程度高，消耗资源高在 PoW 共识中，用户必须完成任意难度的任务，当与块中的有序交易结合时，会产生符合特定标准的哈希函数结果。\n\n\n称为“矿工”的节点通过暴力竞争来解决数学问题（找到特定规则的哈希值）\n第一个解决问题的矿工可以创建一个区块\n其他节点检查该块是否有效。如果是，矿工将获得加密货币奖励。如果不是，矿工就浪费了时间和精力。\n所有的节点都将新块添加到其区块链副本中。\n\n5.2 股权证明 (PoS)\n去中心化的一种妥协方案，更像选择代表人参与网络，相比工作量证明大大降低资源消耗\n\n\n称为验证者节点会抵押一些加密货币。投入一定数量的加密货币来参与和分配出块奖励。\n验证者节点所占的权重越高更有可能被选择来处理交易并创建区块。\n其他验证者节点检查该块是否有效。如果是，所有参与的验证者都会赚取收益。如果不是，创建该块的验证者可能会失去其权益或者获得惩罚。\n\n还有其他共识算法将后续介绍，比如：权威证明、委托权益证明等\n","categories":["blockchain-collection"],"tags":["blockchain"]},{"title":"01-分布式基础理论","url":"/blog/2024/05/13/blockchain/0-base/01-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/","content":"1.分布式基础理论1.1 CAP理论是分布式系统的基石Consistency (一致性)：\n“all nodes see the same data at the same time”，即更新操作成功并返回客户端，所有节点在同一时间的数据完全一致，一致性的问题在并发系统中不可避免。\n对于客户端，一致性指的是并发访问时更新过的数据如何获取。\n对于服务端，则是更新如何复制分布到整个系统，以保证数据一致。\nAvailability (可用性):\n“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。良好的可用性是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。\nPartition Tolerance (分区容错性):\n即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。\n比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。\n1.2 三者只能取其二\nCA without P： 如果不要求P（不允许分区），则保留C（强一致性）和A（可用性），但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，这是有违背分布式系统的设计初衷。\nCP without A： 如果不要求A（可用），强调各服务之间数据强一致性，而P（分区）会导致同步时间无限延长(等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验。\nAP wihtout C： 要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，这样会导致全局数据的不一致性。\n\n1.3 Base理论BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写\nBASE是对CAP中一致性和可用性权衡的结果，核心思想是：即使无法做到强一致性，采用适当的方式使系统达到最终一致性。\nBasically Available: 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性，但不等价于系统不可用。\n\n秒杀的场景下用户数量暴增，为保护系统稳定性，有部分用户可能被引导至一个降级页面\n\nSoft state: 允许系统中的数据存在中间状态，并认为中间状态不会影响系统整体可用性，即允许系统在不用节点之间数据同步存在延时\nEventually consistent: 强调所有的数据副本在经过一段时间同步后，最终能够达成一致的状态。最终保证一致，而不是实时保证系统一致性。\nBASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。\n2.区块链不可能三角区块链通常在安全性、去中心化和可扩展性之间进行权衡：\n\n比特币：重点放在安全性和去中心化上，因此导致比特币的可扩展性受限，因为比特币的区块大小和区块时间设定限制了它的交易处理能力。在需求高的时候就会导致交易延迟和手续费上涨。\n以太坊：重点也放在安全性和去中心化上，并作为智能合约平台，它需要确保用户的资产和协议是安全的。因此以太坊的可扩展性较差，尤其当DeFi和NFT的应用量增大时，交易延迟与费用上涨的问题尤其突出。\nSolana：主要关注可扩展性因此在处理速度和吞吐量上都非常高效，为了达到这样的性能，在网络的中心化程度作出了一些妥协，例如限制验证者的数量。\n\n3.概率最终性和逐块最终性概率最终性：在比特币网络中，由于采用了Proof-of-Work的共识算法。尽管一个区块被添加到区块链上，但仍然存在一定的概率（尽管很小），在后续的区块中被另一个竞争者的区块所取代。因此，对于比特币网络来说，一个最新的区块在一段时间后可以被认为具有概率最终性，即随着更多的区块被添加到区块链上，该区块被替代的概率会逐渐减小。\n逐块最终性：对于Cosmos网络，它采用了Tendermint共识算法，该算法通过验证人的投票来确定下一个区块的生成者。一旦在Cosmos网络中的一个区块被验证人成功生成并广播出去，它被认为是最终的结果，不会被后续的区块替代。因此，可以说Cosmos网络具有逐块最终性，即一旦一个区块在网络中被验证人确认，它就成为最终的结果。\n","categories":["blockchain-collection"],"tags":["blockchain"]},{"title":"02-探讨事务一致性","url":"/blog/2024/05/16/blockchain/0-base/02-%E6%8E%A2%E8%AE%A8%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7/","content":"1.事务的ACID特性在数据库中，“事务”是由多个操作构成的序列。广义上的事务一致性具化到了原子性、一致性、隔离性和持久性这4个方面。\n\n原子性（Atomicity）：指事务是一个不可分割的操作单元，要么全部执行成功，要么全部失败回滚。如果事务中的任何一个操作失败，整个事务将回滚到最初的状态。\n一致性（Consistency）：指事务将数据库从一个一致状态转变为另一个一致状态。在事务开始和结束时，数据库必须满足预定义的一致性规则，以保持数据的有效性和完整性。\n隔离性（Isolation）：指每个事务的执行应该与其他事务的执行相互隔离，以防止彼此干扰。隔离级别定义了事务之间的隔离程度，包括已提交读、可重复读、快照隔离和可串行化。\n持久性（Durability）：指一旦事务提交，其结果就应该永久保存在数据库中，即使系统发生故障也不会丢失。数据库通过将事务日志持久化到磁盘来实现持久性。\n\n\n1.1 原子性和一致性的差异原子性关注事务内部状态，要不全部成功，要不全部失败\n一致性关注数据可见性，中间状态的数据对外不可见，只有最初状态和最终状态的数据对外可见\n1.2 持久性核心思想即应对系统故障\n目的都是保证在本地节点之外，至少有一份完整的日志可用于数据恢复。\n\n存储硬件无损、可恢复故障： 主要依托于预写日志（Write Ahead Log, WAL）保证第一时间存储数据。WAL采用顺序写入的方式，可以保证数据库的低延时响应。\n存储硬件损坏、不可恢复的故障： 需要用到日志复制技术，将本地日志及时同步到其他节点。\n\n单体数据库自带的同步或半同步的方式，其中半同步方式具有一定的容错能力\n日志存储到共享存储系统上，后者会通过冗余存储保证日志的安全性\n基于Paxos&#x2F;Raft的共识算法同步日志数据，在分布式数据库中被广泛使用\n\n1.3 隔离性分为多个隔离级别\n较低的隔离级别就是在正确性上做妥协，将一些异常现象交给应用系统的开发人员去解决，从而获得更好的性能。\n\n最早、最正式的对隔离级别的定义，是ANSI SQL-92（简称SQL-92），它定义的隔离级别和异常现象如下所示：\n\n1.4 更严谨的隔离级别参考论文“A Critique of ANSI SQL Isolation Levels”（简称Critique）\n定义了六种隔离级别和八种异常现象\n\n\nSQL-92中可重复读与可串行化两个隔离级别的主要差别是对幻读的处理，是不是解决了幻读就是可串行化\nCritique的发表，快照隔离能解决幻读的问题，但却无法处理写倾斜（Write Skew）问题，也不符合可串行化要求\n\n对比总结到今天，使用最广泛的隔离级别为四种：已提交读、可重复读、快照隔离、可串行化\n1.5 异常现象不可重复读和幻读的差异在语义上接近：都是在一个事务内用相同的条件查询两次，但两次的结果不一样\n不可重复读：第二次的结果集相对第一次，有些记录被修改（Update）或删除（Delete）了\n幻读： 第二次结果集里出现了第一次结果集没有的记录(Insert)，幻读是在第一次结果集的记录“间隙”中增加了新的记录\n1.6 快照隔离 &amp;&amp; 可重复读\n两者在强度上并列，已提交读弱于这两者，大多数数据库支持的隔离级别就在这三者之中\n\n快照隔离的实现基础则是多版本并发控制（MVCC），用于更高效地实现乐观或悲观并发控制。\n快照隔离存在写倾斜的问题：\n\n两个事务T1、T2同时针对10个变量赋值\nT1将10个变量赋值A，T2将10个变量赋值B，在多事务并行下得到结果将是5个A和B\n\n根据可串行化的定义，“多事务并行执行所得到的结果，与串行执行（一个接一个）完全相同”。\n实现可串行化：先执行T1再执行T2，10个变量都会变成A；调换T1与T2的顺序，则10个变量都是B。\n1.7 数据一致性和事务一致性\n数据一致性关注的是单对象、单操作在多副本上的一致性\n事务一致性则是关注多对象、多操作在单副本上的一致性\n\n分布式数据库的一致性是数据一致性与事务一致性的融合。\n分布式数据“强一致性”的含义，意味着要实现严格串行化，同时也带来性能上的损失。\n降低隔离级别则是在正确性上做妥协，将异常给应用开发处理，从而过的更好的性能。\n","categories":["blockchain-collection"],"tags":["blockchain"]},{"title":"01-基础数据类型","url":"/blog/2023/03/04/software-test-collection/01-10_python%E5%9F%BA%E7%A1%80/01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"1.基础数据类型1.1 变量赋值和引用\n每定义一个新变量时,就会在内存中开辟一块空间用于数据存储。不同的变量,内存地址是不同的。\n使用 id() 获取内存地址，使用 is 判断变量内存地址是否相同。\n\n\n把一个变量的内存地址同时关联到另一个变量上,称为引用。两个变量对应同一块内存地址\na = 100b = aassert id(a) == id(b)assert a is b\n\n不可变类型变量和可变类型变量在引用时的区别\n常用int、字符串都是不可变类型, 字典、集合、列表都属于可变类型的变量\n# b引用a所指向的数据a = 100b = aassert id(a) == id(b)assert a is ba = 100b = aa = 200print(a, b)  # 200 100assert a is not bassert id(a) != id(b)a1 = &quot;str&quot;b1 = a1a1 = &quot;string&quot;print(a1, b1)  # string stra = [1, 2, 3, 4]b = aa[0] = 100print(a[0], b[0])  # 100, 100assert a is bassert id(a) == id(b)\n\n1.2 小整数池和字符串驻留Python中存在一个小整数池，范围通常在-5到256之间。在这个范围内的整数会被提前创建并缓存，以便节省内存。    \n字符串驻留范围:英文字母、数字、下划线\n以下代码在Ipthon中执行,使用Vscode和PythonCharm执行结果可能不同\n# 在ipython中执行a = 100b = 100print(a is b)  # Truea = 500b = 500print(id(a) == id(b))  # Falsea, b = 500, 500print(a is b) # True 一行定义两个相同值的变量,解释器会优化,a、b是同一内存地址a = &quot;abc&quot;b = &quot;abc&quot;print(a is b)  # Truea = &quot;abc!&quot;b = &quot;abc!&quot;print(a is b)  # False\n\n\n\n1.3 数据类型数值: int float bool complex(复数)序列: str list tuple散列: set dict  \n\n常见基础面试题\n\n列表去重方案\n# 方案一  set() 利用集合去重的特性original_list = [1, 2, 3, 4, 3, 2, 1]deduplicated_list = list(set(original_list))print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案二  使用enumerate 找到列表下标判断元素是否存在deduplicated_list = [x for i, x in enumerate(original_list) if x not in original_list[:i]]print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案三  使用 dict.fromkeys():利用字典的键的唯一性deduplicated_list = list(dict.fromkeys(original_list))print(deduplicated_list)  # 输出: [1, 2, 3, 4]# 方案四  使用 Counter 是 collections 模块提供的一个计数器对象，可以用来统计元素出现的次数deduplicated_list = list(Counter(original_list)) # Counter(&#123;1: 2, 2: 2, 3: 2, 4: 1&#125;)print(deduplicated_list)  # 输出: [1, 2, 3, 4]\n\n字符串反转\nprint(&quot;第一种方式:&quot;, &quot;&quot;.join(reversed(data)))print(&quot;第二种方式:&quot;, data[::-1])\n\n\n推导式\nlist推导式\nresult = [&quot;data&#123;&#125;&quot;.format(i) for i in range(0, 100) if i % 2 == 0]\n\ndict 推导式\nprint(&#123;f&quot;data&#123;(i + 1)&#125;&quot;: i + 1 for i in range(3)&#125;)  # &#123;&#x27;data1&#x27;: 1, &#x27;data2&#x27;: 2, &#x27;data3&#x27;: 3&#125;\n\nset 推导式\n&#123; expression for item in Sequence if conditional &#125;\n\ntuple 推导式 （生成器表达式）\na = (x for x in range(1,10))  # &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;  生成器对象tuple(a)  # 使用 tuple() 函数，可以直接将生成器对象转换成元组\n\n1.4 collections\n 这个模块实现了一些专门化的容器，提供了对 Python 的通用内建容器 dict、list、set 和 tuple 的补充。\n\nfrom collections import namedtuple, deque, ChainMap# namedtuple 命名元祖Student = namedtuple(&#x27;Students&#x27;, [&quot;name&quot;, &quot;age&quot;, &#x27;index&#x27;])tu1 = Student(name=&quot;张三&quot;, age=18, index=1)print(tu1.name)  # 张三print(isinstance(tu1, tuple))  # True 也是元祖类型数据print(type(tu1))  # tu1数据类型 &lt;class &#x27;__main__.Students&#x27;&gt; Student对象# deque 双端队列d = deque(&#x27;ghi&#x27;)d.extendleft(&#x27;123&#x27;, )d.appendleft(&#x27;4&#x27;)print(d)   # deque([&#x27;4&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;])# ChainMap 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图dict1 = &#123;&#x27;music&#x27;: &#x27;bach&#x27;, &#x27;art&#x27;: &#x27;rembrandt&#x27;&#125;dict2 = &#123;&#x27;art&#x27;: &#x27;van gogh&#x27;, &#x27;opera&#x27;: &#x27;carmen&#x27;&#125;dict3 = &#123;&#x27;opera&#x27;: &#x27;dict3&#x27;, &#x27;test&#x27;: &#x27;dict3&#x27;&#125;c = ChainMap(dict1, dict2, dict3)# 获取map中的key和其传入参数有关系, 迭代顺序是通过从后往前扫描print(c.get(&#x27;art&#x27;), c.get(&#x27;opera&#x27;))  # rembrandt, carmen# 如果要实现dict.update功能,可以使用update()c.update(dict3)print(c.get(&#x27;art&#x27;), c.get(&#x27;opera&#x27;))  # rembrandt, dict3\n\n\n\n1.5 iterable可迭代对象: 可被 for 遍历都是可迭代对象  \n\n实现了 iter 方法，并且该方法返回一个迭代器对象。  \n实现了 getitem 方法，并且可以通过索引访问元素。\n\n\nclass collections.abc.Iterable\n提供了 __iter__() 方法的抽象基类。\n使用 isinstance(obj, Iterable) 可以检测一个类是否已经注册到了 Iterable 或者实现了 __iter__() 函数，但是无法检测这个类是否能够使用 __getitem__() 方法进行迭代。检测一个对象是否是 iterable 的唯一可信赖的方法是调用 iter(obj)。\n\n示例1: 实现 __iter__ 但是返回一个list 非迭代器对象  \nclass Iterable1:    def __init__(self):        self.data = [1, 2, 3, 4]    def __iter__(self):        # 返回的是一个列表,而不是一个迭代器对象        return self.dataobj1 = Iterable1()assert isinstance(obj1, Iterable)  # Trueassert iter(obj1)  # iter() returned non-iterator of type &#x27;list&#x27;\n\n示例2: 实现 __iter__ 返回一个迭代器对象  \nclass Iterable2:    def __init__(self):        self.data = [1, 2, 3, 4]    def __iter__(self):        # 返回的是一个迭代器对象        return iter(self.data)obj2 = Iterable2()  # obj2 是可以被for遍历的对象print(iter(obj2)) # &lt;list_iterator object at 0x1043bb6d0&gt;\n\n示例3: 实现 __getitem__ 访问元素  \nclass Iterable3:    def __init__(self):        self.data = [1, 2, 3, 4, 5]    def __getitem__(self, index):        # 通过索引访问元素，实现迭代行为        return self.data[index]my_iterable = Iterable3()print(iter(my_iterable))\n\n\n\n1.6 iterator迭代器:必须要同时拥有 __iter__ 和 __next__ 方法才是迭代器\n\n迭代器调用 __next__ 方法会调用迭代器中的下一个值\n\n示例1:通过 iter(iterable) 得到迭代器\nmy_iterator = iter([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])# hasattr 判断某个对象是否包含某个属性信息print(hasattr(my_iterator, &quot;__iter__&quot;))  # Trueprint(hasattr(my_iterator, &quot;__next__&quot;))  # True\n\n示例2:实现一个迭代器，必须要实现 __next__ 和 __iter__ 方法\n\n示例中并没有手动实现 __iter__ 会使用父类的 __iter__ \n\nfrom typing import Iteratorclass Students(Iterator):    def __init__(self):        self.students = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]        self.index = 0    def __next__(self):        if self.index &gt;= len(self.students):            raise StopIteration        self.index += 1        return self.students[self.index - 1]print(isinstance(Students(), Iterator))  # Trueprint(my_iterator.__iter__())  # &lt;__main__.Students object at 0x1009a7950&gt;for item in Students():    print(item)  \n\n示例3:实现一个迭代器，自己实现 __init__ 方法\nclass Students2(Iterator):    def __init__(self):        self.students = [&quot;1&quot;, &quot;2&quot;]        self.index = 0    def __iter__(self):        return iter(self.students)    def __next__(self):        if self.index &gt;= len(self.students):            raise StopIteration        self.index += 1        return self.students[self.index - 1]my_iterator2 = Students2()print(my_iterator2.__iter__())  # &lt;list_iterator object at 0x104f37fd0&gt;print(isinstance(my_iterator2, Iterator))  # Trueprint(next(my_iterator2))  # 1print(next(my_iterator2))  # 2print(next(my_iterator2))  # raise StopIteration\n\n示例4:实现一个 range 迭代器\n\n\nrange 方法的签名 start、stop 两个参数\n__iter__ 方法要求返回值必须是一个”迭代器“ (或者返回值必须要有 __next__ 方法)\n\n\nclass Next:    def __init__(self, stop, start=-1):        self.start = start        self.stop = stop    def __next__(self):        if self.start &gt;= self.stop - 1:            raise StopIteration        self.start += 1        return self.startclass MyRange:    def __init__(self, stop):        self.stop = stop    def __iter__(self):        return Next(self.stop)my_range = MyRange(5)  # &lt;__main__.MyRange object at 0x1045029d0&gt;# False 断言它不是一个迭代器,但是它可以被for遍历,所以__iter__返回值有__next__方法也可以print(isinstance(my_range, Iterator)) for item in my_range:    print(item)  # 也可以通过 for 遍历\n\n示例5: 基于MyRange使用while实现for \n\nfor 会自动调用 __iter__ , __next__ 方法,但是while不会,需要手动调用\n\n# 基于MyRange使用while实现fordef my_while():    start, stop = 0, 5    my_range = MyRange(stop)    numbers = my_range.__iter__()  # 手动调用__iter__方法    while start &lt; stop:        print(numbers.__next__())        start += 1my_while()\n\n\n\n1.7 generator生成器(高效):生成器是特殊的迭代器,迭代器是特殊的可迭代对象,那么生成器必定是可迭代对象\n\n使用yield关键字返回一个生成器对象\n\nfrom typing import Iterable, Iteratordef g_func2():    my_list = range(3)    for i in my_list:        yield i * ig = g_func2()print(isinstance(g, Iterable))  # Trueprint(g.__iter__())  # &lt;generator object g_func1 at 0x10271fc10&gt;print(next(g))print(next(g))print(next(g))print(hasattr(g, &quot;__iter__&quot;))  # Trueprint(hasattr(g, &quot;__next__&quot;))  # Trueprint(isinstance(g, Iterator))  # True\n\n\n\n1.8 for循环的本质\n\n调用iter()，将numbers转化为迭代器numbers_iterator\n调用next(numbers_iterator)，返回出numbers的第一个元素\n循环步骤2,迭代完numbers内所有数据,捕获异常\n\n\n# while + iteratornumbers = [1, 2, 3, 4]numbers_iterator = iter(numbers)while True:    try:        print(next(numbers_iterator))    except StopIteration:  # 捕捉异常终止循环        break# for循环for i in numbers:    print(i)\n\n\n\n1.9 itertools\n为高效循环而创建迭代器的函数\n\niterable = itertools.chain([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;])for i in iterable:    print(i)  # --&gt; A B C D E Ffrom_iterable = itertools.chain.from_iterable([&#x27;ABC&#x27;, &#x27;DEF&#x27;])for i in from_iterable:    print(i)r = itertools.combinations(&quot;ABCD&quot;, 2)for i in r:    print(i)  # --&gt; AB AC AD BC BD CD\n\n\n\n1.10 lambda、map、zip\nlamdba 处理简单业务逻辑\ny: any = lambda x: x + 1print(y(10))Students = [    &#123;&quot;name&quot;: &quot;a&quot;, &quot;age&quot;: 18&#125;,    &#123;&quot;name&quot;: &quot;c&quot;, &quot;age&quot;: 20&#125;,    &#123;&quot;name&quot;: &quot;b&quot;, &quot;age&quot;: 19&#125;,    &#123;&quot;name&quot;: &quot;ca&quot;, &quot;age&quot;: 19&#125;,    &#123;&quot;name&quot;: &quot;cb&quot;, &quot;age&quot;: 19&#125;]# 根据age排序,age一致时根据name排序print(sorted(Students, key=lambda student: (student[&quot;age&quot;], student[&quot;name&quot;])))\n\nmap(func, *iterables) –&gt; map object\n# map 可迭代对象元素合并 返回新的map对象,按最短的对象合并a = [1, 2, 3]b = [4, 5, ]# map(func, *iterables)# func --&gt; lambda a1, b1: (a1, b1)# *iterables --&gt; a, bnum1 = map(lambda a1, b1: (a1, b1), a, b)  # &lt;map object at 0x109efed60&gt;for i in num1:    print(i)  # (1, 4), (2, 5)\n\nreduce 求和\nfrom functools import reduceprint(reduce(lambda x, y: x + y, range(1, 101)))  # 5050\n\nfilter 过滤\nprint(list(filter(lambda x: x &gt; 5, range(10))))  # &lt;filter object at 0x106ad6c40&gt;\n\nzip\na = [1, 2, 3]b = [4, 5, 6, 7, 8]print(list(zip(a, b)))  # [(1, 4), (2, 5), (3, 6)]  # 元素个数与最短的列表一致\n\n1.11 namespace\n一般有三种命名空间:\n\n内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。\n全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。\n局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）\n\n\nPython的作用域一共有4种【规则顺序: L –&gt; E –&gt; G –&gt; gt; B】\n\nL（Local）:最内层，包含局部变量，比如一个函数&#x2F;方法内部。\n\nE（Enclosing）:包含了非局部(non-local)也非全局(non-global)的变量。\n比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。\n\nG（Global）:当前脚本的最外层，比如当前模块的全局变量。\n\nB（Built-in）: 包含了内建的变量&#x2F;关键字等。最后被搜索\n\n\n\n闭包\n\n1.在一个函数内部定义了另一个函数2.内部函数引用了外部函数的变量\n\ng_count = 0  # 全局作用域def outer():    o_count = 1  # 闭包函数外，函数中    print(f&quot;Enclosing: &#123;o_count&#125;&quot;)    def inner():        i_count = 2  # 局部作用域        print(f&quot;Local: &#123;i_count&#125;&quot;)        nonlocal o_count  # 外层作用域        o_count += 5        print(f&quot;Enclosing: &#123;o_count&#125;&quot;)    return inner  # 返回函数名称 可以被调用print(f&quot;Global: &#123;g_count&#125;&quot;)  # Global: 0func = outer()  # Enclosing: 1func()  # Local: 2 Enclosing: 6func()  # Local: 2 Enclosing: 11\n\n1.12 private_name# import 私有变量# 1. __name它不会被导入到导入模块的命名空间中# 2. _name会被导入到导入模块的命名空间中class MyClass:    def __init__(self):        self.__name = &quot;Private Name&quot;  # 私有变量 __name        self._name = &quot;Conventionally Private Name&quot;  # 约定上的私有变量 _name    def get_private_name(self):        return self.__name    def get_conventionally_private_name(self):        return self._nameobj = MyClass()# 访问私有变量 __nameprint(obj.get_private_name())  # 输出: Private Name# print(obj.__name)  # 错误，在类外部，无法直接访问私有变量，会引发 AttributeError 错误print(obj._MyClass__name)  # 输出: Private Name，通过名称重整方式访问私有变量# 访问约定上的私有变量 _nameprint(obj.get_conventionally_private_name())  # 输出: Conventionally Private Nameprint(obj._name)  # 输出: Conventionally Private Name，可以直接访问约定上的私有变量\n","categories":["software-test-collection"],"tags":["software-test","python"]},{"title":"OrbitDB-初体验","url":"/blog/2024/05/15/note/open-source/OrbitDB-%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"1.项目分析1.1 项目分析为去中心化网络设计的点对点（P2P）数据库，下面是关于 OrbitDB 的一些关键点和如何部署及与之交互的概述：\n1.2 主要功能\n无服务器（Serverless）：不需要中心化的服务器来运行。\n分布式（Distributed）：数据分布在网络中的各个节点上。\n点对点（Peer-to-Peer）：直接在用户之间同步数据，不需要通过中介。\n使用 IPFS 作为数据存储：IPFS（InterPlanetary File System）是一个分布式文件系统，用于存储和访问文件、网站、应用程序等。\n使用 Libp2p Pubsub 进行数据库同步：Libp2p 是一个模块化的网络栈，Pubsub 是它的一个模块，用于发布和订阅消息，以实现数据库的自动同步。\n最终一致性（Eventually Consistent）：数据库保证了在没有冲突的情况下，最终所有副本都将达到一致的状态。\n使用 Merkle-CRDTs 进行冲突自由的数据库写入和合并：CRDTs（Conflict-free Replicated Data Types）是一种特殊类型的数据结构，允许在没有中心协调者的情况下进行数据的并发更新。\n\n1.3 数据库类型OrbitDB 提供了不同类型的数据库以适应不同的数据模型和用例：\n\nevents：不可变的（仅追加）日志，具有可遍历的历史记录。\ndocuments：可以存储和按指定键索引 JSON 文档的文档数据库。\nkeyvalue：类似于传统的键值数据库。\nkeyvalue-indexed：在 LevelDB 中索引的键值数据。\n\n1.4 部署和交互\n安装：可以通过 npm 安装 OrbitDB 及其依赖：\nnpm install @orbitdb/core helia\n\n浏览器中使用：OrbitDB 可以通过在 HTML 文件中使用 &lt;script&gt; 标签来加载：\n&lt;script src=&quot;/path/to/orbitdb.min.js&quot;&gt;&lt;/script&gt;\n\n快速开始：可以使用 @orbitdb/quickstart 模块快速开始使用 OrbitDB。\n\n使用：在浏览器或 Node.js 应用中，可以将 @orbitdb/core 作为一个模块与 IPFS 的 JavaScript 实例一起使用。以下是创建和使用数据库的示例代码：\nimport &#123; createHelia &#125; from &#x27;helia&#x27;;import &#123; createOrbitDB &#125; from &#x27;@orbitdb/core&#x27;;import &#123; gossipsub &#125; from &quot;@chainsafe/libp2p-gossipsub&quot;;import &#123; identify &#125; from &quot;@libp2p/identify&quot;;import &#123; createLibp2p &#125; from &#x27;libp2p&#x27;;// 创建 Libp2p 实例和 IPFS 实例const libp2p = await createLibp2p(&#123; /* options */ &#125;);const ipfs = await createHelia(&#123; libp2p &#125;);const orbitdb = await createOrbitDB(&#123; ipfs &#125;);// 创建/打开数据库const db = await orbitdb.open(&quot;my-database-name&quot;);// 监听来自其他节点的更新db.events.on(&quot;update&quot;, async (entry) =&gt; &#123;  // 处理更新&#125;);// 添加条目到数据库const hash = await db.add(&#123; content: &quot;Hello, OrbitDB!&quot; &#125;);// 查询数据库for await (const record of db.iterator()) &#123;  // 处理记录&#125;// 关闭数据库和 IPFS 实例await db.close();await orbitdb.stop();await ipfs.stop();\n\n持久化和连接：为了配置 IPFS 实例的持久化和 Libp2p 连接到其他节点，可以参考 @orbitdb/quickstart 中的 Helia 实例创建和默认的 Libp2p 配置。\n\n文档和开发：项目的 README 中提供了更多关于如何运行测试、构建项目、基准测试和构建 API 文档的指导。\n\n\n","tags":["open-source"]},{"title":"python-路径导入问题","url":"/blog/2023/01/10/note/python/py-%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/","content":"python文件运行时路径导入的问题\n 错误提示：ModuleNotFoundError: No module named ‘xxxx’\n\n解决这个问题首先要明白Python运行时，Python解释器会按照一定的搜索路径来查找模块和包。\n可以通过sys.path查看具体信息\nimport sysprint(sys.path)\n\n[&#x27;/Users/jw/Documents/github/abcd/b&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python312.zip&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12&#x27;, &#x27;/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/lib-dynload&#x27;, &#x27;/opt/homebrew/lib/python3.12/site-packages&#x27;, &#x27;/Users/jw/Documents/github/abcd&#x27;]\n\n\n当前工作目录：即列表下标为0的元素，解释器会首先在当前目录中搜索模块，当前工作目录是指在运行Python脚本时所在的目录\nPYTHONPATH环境变量：PYTHONPATH环境变量可以用来指定额外的模块搜索路径。它是一个包含多个目录路径的列表，Python解释器会按照列表中的顺序进行搜索。\n\n# 可以通过以下命令在终端查看echo $PYTHONPATH \n\n这种方式比较隐蔽，不常用，需要操作者知情才会去查看此环境变量\n\n系统默认路径：Python解释器会在一组默认的系统路径中搜索模块。这些路径包括Python标准库的位置以及安装的第三方库的位置。【参考上述path路径中展示，除最后一个元素和第一个元素外】\n\n解决方案abcd/├── a/│ ├── init.py│ └── m.py           # m.py中有一个变量 aa = 11└── b/├── init.py└── mb.py          #  在此路径下运行 mb.py 文件 并打印出变量 aa\n\n# mb.pyfrom a.m import aaprint(aa)File &quot;/Users/jw/Documents/github/abcd/b/mb.py&quot;, line 29, in &lt;module&gt;    from a.m import aaModuleNotFoundError: No module named &#x27;a&#x27;\n\n将模块a添加至path路径中\nimport sysfrom pathlib import Pathroot_path = Path(__file__).resolve().parent.parentsys.path.append(str(root_path))  # 将root_path添加到PATH，并会在此模块下搜索print(sys.path)  # 此处会输出path的所有内容from a.m import aaprint(aa)   # 成功输出变量信息\n\n\n\n类似场景abcd/├── a/│ ├── init.py│ └── m.py           # m.py中有一个变量 aa = 11└── b/├── init.py└── mb.py            #  在此路径下运行 mb.py 文件 并打印出变量 aa└ main.py             # 程序主入口\n\n# mian.pyfrom a.m import aaprint(aa)\n\nmain.py 无需添加至PATH即可成功输出aa变量的原因现在知道了吗？\n根据上述结论推导：\nmain.py文件在运行时，会在当前工作目录下搜索包，即能找到a模块也可以找到b模块，无需添加\n\n","tags":["python","note"]},{"title":"python-重复逻辑优化篇","url":"/blog/2023/08/21/note/python/py-%E9%87%8D%E5%A4%8D%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96%E7%AF%87/","content":"1.解决api请求变更,URL和参数更新维护等问题？引入客户端代码生成工具,根据接口文档自动生成代码,从而减少由于接口变更的维护成本\n官网地址: https://swagger.io/tools/swagger-codegen/\n\n下载swagger codegen \n生成对应语言客户端代码  [-i 指定api接口路径,-lang 指定语言,-o 指定生成代码文件路径]\n\n阅读生成项目的readme,提供了使用教程​\t\t\nswagger-codegen generate -i http://ip:port/static/openapi.yml --lang python -o ./me_api_clientswagger-codegen generate -i http://ip:port/static/openapi.yml --lang go -o ./me_api_client\n\n\n\n\n2. 项目结构分析\n客户端需要连接到指定节点，能提供多节点测试\n客户端需要提供命令生成器 和 执行器\n操作每个模块都需要自定义其模块方法，成本较高，并且大致逻辑一致\n\nNode模块：\n\n初始化node实例提供连接节点功能\nnode实例默认提供对应 交易的一些常用命令设置\nnode都绑定有执行器(executor) 和 命令生成器（generate_xxx）\n\nimport inspectfrom typing import Callablefrom loguru import loggerfrom config.config import app_chainfrom ssh import Client, Resultclass Node:    ssh_client = Client(ip=app_chain.Host.ip, port=app_chain.Host.port,                        username=app_chain.Host.username, password=app_chain.Host.password)    config = app_chain    def __init__(self, node: str):        super().__init__()        if &quot;--node&quot; not in node:            node = f&quot;--node=&#123;node&#125;&quot;        self.config.Flags.node = node        self.superadmin = self.__get_superadmin_addr()        self.__init_instance_config()    def update_config(self, attr: str, key: str, value: str):        &quot;&quot;&quot;        If key exists in the attr object, replace the value. If no, add the value        :param attr: &#x27;ApplicationChain&#x27; object must have attr        :param key:        :param value:        :return:        &quot;&quot;&quot;        sub_cfg_gen = getattr(self.config, attr)        found_key = False        for i in sub_cfg_gen:            if i[0] == key:                setattr(sub_cfg_gen, key, value)                found_key = True                break        if not found_key:            setattr(sub_cfg_gen, key, value)    def __init_instance_config(self):        self.update_config(&quot;Flags&quot;, &quot;fees&quot;, &quot;--fees=100umec&quot;)        self.update_config(&quot;Flags&quot;, &quot;gas&quot;, &quot;--gas=200000&quot;)    @property    def base_cmd(self):        return f&quot;&#123;self.config.Host.chain_work_path&#125; &quot;    def __get_superadmin_addr(self):        get_superadmin_cmd = f&quot;&#123;self.base_cmd&#125; keys show superadmin -a &#123;self.config.Flags.keyring_backend&#125;&quot;        return self.ssh_client.exec_cmd(get_superadmin_cmd)    def generate_query_cmd(self, cmd: str):        query_cmd = self.base_cmd + f&quot;&#123;self.config.Flags.node&#125; &#123;self.config.GlobalFlags.chain_id&#125; &quot;        return query_cmd + cmd    def generate_tx_cmd(self, cmd: str):        tx_cmd = self.base_cmd + (f&quot;&#123;self.config.Flags.fees&#125; &#123;self.config.Flags.gas&#125; &quot;                                  f&quot;&#123;self.config.Flags.yes&#125; &#123;self.config.Flags.keyring_backend&#125; &quot;                                  f&quot;&#123;self.config.Flags.node&#125; &#123;self.config.GlobalFlags.chain_id&#125; &quot;)        return tx_cmd + cmd    def generate_keys_cmd(self, cmd: str):        keys_cmd = self.base_cmd + f&quot;&#123;self.config.Flags.keyring_backend&#125; &quot;        return keys_cmd + cmd    def executor(self, cmd):        logger.info(f&quot;&#123;inspect.stack()[0][3]&#125;: &#123;cmd&#125;&quot;)        if &quot;keys add&quot; in cmd:            _ = self.ssh_client.channel.send(cmd + &quot;\\n&quot;)            resp_info = self.ssh_client.Interactive.read_channel_data(self.ssh_client.channel)            if &quot;existing&quot; in resp_info:                resp_info = self.ssh_client.Interactive.input_yes_or_no(self.ssh_client.channel)            assert &quot;**Important**&quot; in resp_info            return resp_info        resp_info = self.ssh_client.exec_cmd(cmd, strip=False)        if resp_info.failed:            logger.info(f&quot;resp_info.stderr: &#123;resp_info.stderr&#125;&quot;)            return resp_info.stderr        return Result.yaml_to_dict(resp_info.stdout)\n\n\n\nMeta元类:\n为每个类动态生成方法,解决其定义冗余\nclass Meta(type):    def __init__(cls, name, bases, attrs):        cls.module = name.lower()  # 创建类module = 其类名称小写        super().__init__(name, bases, attrs)        sub_module = attrs.get(&#x27;sub_module&#x27;, [])        parent_module = attrs.get(&#x27;parent_module&#x27;, &#x27;&#x27;)        if isinstance(sub_module, list):            for module in sub_module:              \t# 添加类方法，名称为其子模块                method = cls.generate_method(parent_module, module)                setattr(cls, module, classmethod(method))        elif isinstance(sub_module, dict):            for k, module in sub_module.items():                method = cls.generate_method(parent_module, module)                setattr(cls, k, classmethod(method))        else:            raise f&quot;sub_module type error: &#123;type(sub_module)&#125;, expect list or dict&quot;    @staticmethod    def generate_method(parent_module, sub_module) -&gt; Callable[..., str]:       # 利用闭包特性，生成的类方法只接受 *args,**kwargs 参数        def method(cls, *args, **kwargs):            return cls.build_command(parent_module, sub_module, *args, **kwargs)        return method    def build_command(cls, parent_module, sub_module, *args, **kwargs):        args_str = &quot; &quot;.join(map(str, args))        kwargs_str = &quot; &quot;.join([f&quot;--&#123;key&#125;=&#123;value&#125;&quot; for key, value in kwargs.items() if value != &quot;&quot;])        return f&quot;&#123;parent_module&#125; &#123;cls.module&#125; &#123;sub_module&#125; &#123;args_str&#125; &#123;kwargs_str&#125; &quot;    def __getattr__(cls, attr):        raise AttributeError(f&quot;&#x27;&#123;cls.__name__&#125;&#x27; class has no attribute &#x27;&#123;attr&#125;&#x27;&quot;)    def help(cls):        for attr_name in cls.sub_module:            attr = getattr(cls, attr_name)            if not callable(attr):                raise TypeError(f&quot;attribute &#x27;&#123;attr_name&#125;&#x27; is not callable&quot;)        print(f&quot;Available methods: &#123;list(cls.sub_module)&#125;&quot;)        print(f&quot;Example usage: &#123;cls.__name__&#125;.&#123;list(cls.sub_module)[0]&#125;(&#x27;argument&#x27;)&quot;)\n\n\n\n","tags":["python","tools"]}]